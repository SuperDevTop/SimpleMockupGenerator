; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23026.0 

	TITLE	C:\Users\lucas\Documents\Quazip\zlib1211\zlib-1.2.11\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCodesUsed@4
PUBLIC	_inflateMark@4
PUBLIC	_inflateValidate@8
PUBLIC	_inflateUndermine@8
PUBLIC	_inflateCopy@8
PUBLIC	_inflateSyncPoint@4
PUBLIC	_inflateSync@4
PUBLIC	_inflateGetHeader@8
PUBLIC	_inflateSetDictionary@12
PUBLIC	_inflateGetDictionary@12
PUBLIC	_inflatePrime@12
PUBLIC	_inflateInit_@12
PUBLIC	_inflateReset2@8
PUBLIC	_inflateResetKeep@4
PUBLIC	_inflateEnd@4
PUBLIC	_inflate@8
PUBLIC	_inflateInit2_@16
PUBLIC	_inflateReset@4
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 146  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 147  :     struct inflate_state FAR *state;
; 148  : 
; 149  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateRes
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 155  : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateRes:

; 150  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  0001b	89 4d 08	 mov	 DWORD PTR _strm$[ebp], ecx
  0001e	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0
  00025	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0
  0002c	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [eax+52], 0

; 155  : }

  00033	5d		 pop	 ebp

; 151  :     state->wsize = 0;
; 152  :     state->whave = 0;
; 153  :     state->wnext = 0;
; 154  :     return inflateResetKeep(strm);

  00034	e9 00 00 00 00	 jmp	 _inflateResetKeep@4
_inflateReset@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 201  :     int ret;
; 202  :     struct inflate_state FAR *state;
; 203  : 
; 204  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||

  00003	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  00006	85 c0		 test	 eax, eax
  00008	0f 84 ac 00 00
	00		 je	 $LN3@inflateIni
  0000e	80 38 31	 cmp	 BYTE PTR [eax], 49	; 00000031H
  00011	0f 85 a3 00 00
	00		 jne	 $LN3@inflateIni
  00017	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001b	0f 85 99 00 00
	00		 jne	 $LN3@inflateIni

; 207  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00021	56		 push	 esi
  00022	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00025	85 f6		 test	 esi, esi
  00027	75 08		 jne	 SHORT $LN4@inflateIni
  00029	8d 46 fe	 lea	 eax, DWORD PTR [esi-2]
  0002c	5e		 pop	 esi

; 237  : }

  0002d	5d		 pop	 ebp
  0002e	c2 10 00	 ret	 16			; 00000010H
$LN4@inflateIni:

; 208  :     strm->msg = Z_NULL;                 /* in case we return an error */
; 209  :     if (strm->zalloc == (alloc_func)0) {

  00031	83 7e 20 00	 cmp	 DWORD PTR [esi+32], 0
  00035	c7 46 18 00 00
	00 00		 mov	 DWORD PTR [esi+24], 0
  0003c	75 0e		 jne	 SHORT $LN5@inflateIni

; 210  : #ifdef Z_SOLO
; 211  :         return Z_STREAM_ERROR;
; 212  : #else
; 213  :         strm->zalloc = zcalloc;

  0003e	c7 46 20 00 00
	00 00		 mov	 DWORD PTR [esi+32], OFFSET _zcalloc

; 214  :         strm->opaque = (voidpf)0;

  00045	c7 46 28 00 00
	00 00		 mov	 DWORD PTR [esi+40], 0
$LN5@inflateIni:

; 215  : #endif
; 216  :     }
; 217  :     if (strm->zfree == (free_func)0)

  0004c	83 7e 24 00	 cmp	 DWORD PTR [esi+36], 0
  00050	75 07		 jne	 SHORT $LN6@inflateIni

; 218  : #ifdef Z_SOLO
; 219  :         return Z_STREAM_ERROR;
; 220  : #else
; 221  :         strm->zfree = zcfree;

  00052	c7 46 24 00 00
	00 00		 mov	 DWORD PTR [esi+36], OFFSET _zcfree
$LN6@inflateIni:

; 222  : #endif
; 223  :     state = (struct inflate_state FAR *)

  00059	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0005c	57		 push	 edi
  0005d	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  00062	6a 01		 push	 1
  00064	ff 76 28	 push	 DWORD PTR [esi+40]
  00067	ff d0		 call	 eax
  00069	8b f8		 mov	 edi, eax
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 224  :             ZALLOC(strm, 1, sizeof(struct inflate_state));
; 225  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0006e	85 ff		 test	 edi, edi
  00070	75 09		 jne	 SHORT $LN7@inflateIni
  00072	8d 47 fc	 lea	 eax, DWORD PTR [edi-4]
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi

; 237  : }

  00077	5d		 pop	 ebp
  00078	c2 10 00	 ret	 16			; 00000010H
$LN7@inflateIni:
  0007b	53		 push	 ebx

; 226  :     Tracev((stderr, "inflate: allocated\n"));
; 227  :     strm->state = (struct internal_state FAR *)state;
; 228  :     state->strm = strm;
; 229  :     state->window = Z_NULL;
; 230  :     state->mode = HEAD;     /* to pass state test in inflateReset2() */
; 231  :     ret = inflateReset2(strm, windowBits);

  0007c	ff 75 0c	 push	 DWORD PTR _windowBits$[ebp]
  0007f	89 7e 1c	 mov	 DWORD PTR [esi+28], edi
  00082	56		 push	 esi
  00083	89 37		 mov	 DWORD PTR [edi], esi
  00085	c7 47 38 00 00
	00 00		 mov	 DWORD PTR [edi+56], 0
  0008c	c7 47 04 34 3f
	00 00		 mov	 DWORD PTR [edi+4], 16180 ; 00003f34H
  00093	e8 00 00 00 00	 call	 _inflateReset2@8
  00098	8b d8		 mov	 ebx, eax

; 232  :     if (ret != Z_OK) {

  0009a	85 db		 test	 ebx, ebx
  0009c	74 13		 je	 SHORT $LN8@inflateIni

; 233  :         ZFREE(strm, state);

  0009e	8b 4e 24	 mov	 ecx, DWORD PTR [esi+36]
  000a1	57		 push	 edi
  000a2	ff 76 28	 push	 DWORD PTR [esi+40]
  000a5	ff d1		 call	 ecx
  000a7	83 c4 08	 add	 esp, 8

; 234  :         strm->state = Z_NULL;

  000aa	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0
$LN8@inflateIni:

; 235  :     }
; 236  :     return ret;

  000b1	8b c3		 mov	 eax, ebx
  000b3	5b		 pop	 ebx
  000b4	5f		 pop	 edi
  000b5	5e		 pop	 esi

; 237  : }

  000b6	5d		 pop	 ebp
  000b7	c2 10 00	 ret	 16			; 00000010H
$LN3@inflateIni:

; 205  :         stream_size != (int)(sizeof(z_stream)))
; 206  :         return Z_VERSION_ERROR;

  000ba	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH

; 237  : }

  000bf	5d		 pop	 ebp
  000c0	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv2809 = -64						; size = 4
_in$1$ = -60						; size = 4
$T1 = -56						; size = 4
_copy$9$ = -56						; size = 4
tv2792 = -56						; size = 4
tv2749 = -56						; size = 4
tv2748 = -56						; size = 4
tv2736 = -56						; size = 4
tv2721 = -56						; size = 4
tv2694 = -56						; size = 4
tv2693 = -56						; size = 4
tv2646 = -56						; size = 4
_copy$7$ = -56						; size = 4
_copy$4$ = -56						; size = 4
_copy$3$ = -56						; size = 4
_copy$2$ = -56						; size = 4
_len$5$ = -56						; size = 4
_len$1$ = -56						; size = 4
_last$ = -56						; size = 4
_here$ = -56						; size = 4
_copy$11$ = -52						; size = 4
_copy$8$ = -52						; size = 4
tv2744 = -52						; size = 4
tv2743 = -52						; size = 4
tv2719 = -52						; size = 4
tv2692 = -52						; size = 4
_copy$1$ = -52						; size = 4
tv2812 = -48						; size = 4
_ret$1$ = -44						; size = 4
_from$1$ = -40						; size = 4
tv2819 = -40						; size = 4
tv2728 = -40						; size = 4
tv2718 = -40						; size = 4
tv2717 = -40						; size = 4
_len$4$ = -40						; size = 4
_len$3$ = -40						; size = 4
_len$2$ = -40						; size = 4
_out$1$ = -36						; size = 4
_put$1$ = -32						; size = 4
_hbuf$ = -28						; size = 4
_left$1$ = -24						; size = 4
tv2707 = -20						; size = 4
tv2705 = -20						; size = 4
_bits$1$ = -20						; size = 4
_next$1$ = -16						; size = 4
tv2746 = -12						; size = 4
_have$1$ = -12						; size = 4
_state$1$ = -8						; size = 4
_hold$1$ = -4						; size = 4
tv2674 = 8						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 625  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 626  :     struct inflate_state FAR *state;
; 627  :     z_const unsigned char FAR *next;    /* next input */
; 628  :     unsigned char FAR *put;     /* next output */
; 629  :     unsigned have, left;        /* available input and output */
; 630  :     unsigned long hold;         /* bit buffer */
; 631  :     unsigned bits;              /* bits in bit buffer */
; 632  :     unsigned in, out;           /* save starting available input and output */
; 633  :     unsigned copy;              /* number of stored or match bytes to copy */
; 634  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 635  :     code here;                  /* current decoding table entry */
; 636  :     code last;                  /* parent table entry */
; 637  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 638  :     int ret;                    /* return code */
; 639  : #ifdef GUNZIP
; 640  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 641  : #endif
; 642  :     static const unsigned short order[19] = /* permutation of code lengths */
; 643  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 644  : 
; 645  :     if (inflateStateCheck(strm) || strm->next_out == Z_NULL ||

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	83 ec 40	 sub	 esp, 64			; 00000040H
  00009	8b ca		 mov	 ecx, edx
  0000b	e8 00 00 00 00	 call	 _inflateStateCheck
  00010	85 c0		 test	 eax, eax
  00012	0f 85 b3 16 00
	00		 jne	 $LN333@inflate
  00018	39 42 0c	 cmp	 DWORD PTR [edx+12], eax
  0001b	0f 84 aa 16 00
	00		 je	 $LN333@inflate
  00021	39 02		 cmp	 DWORD PTR [edx], eax
  00023	75 09		 jne	 SHORT $LN332@inflate
  00025	39 42 04	 cmp	 DWORD PTR [edx+4], eax
  00028	0f 85 9d 16 00
	00		 jne	 $LN333@inflate
$LN332@inflate:

; 648  : 
; 649  :     state = (struct inflate_state FAR *)strm->state;

  0002e	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]
  00031	89 4d f8	 mov	 DWORD PTR _state$1$[ebp], ecx

; 650  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00034	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  0003b	75 07		 jne	 SHORT $LN4@inflate
  0003d	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H
$LN4@inflate:

; 651  :     LOAD();

  00044	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00047	89 45 e0	 mov	 DWORD PTR _put$1$[ebp], eax
  0004a	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0004d	89 45 e8	 mov	 DWORD PTR _left$1$[ebp], eax

; 652  :     in = have;
; 653  :     out = left;

  00050	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax

; 654  :     ret = Z_OK;

  00053	33 c0		 xor	 eax, eax
  00055	53		 push	 ebx
  00056	8b 5a 04	 mov	 ebx, DWORD PTR [edx+4]
  00059	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  0005c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0005f	56		 push	 esi
  00060	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00063	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00068	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0006b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0006e	89 5d c4	 mov	 DWORD PTR _in$1$[ebp], ebx
  00071	57		 push	 edi
  00072	8b 3a		 mov	 edi, DWORD PTR [edx]
  00074	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00077	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0007a	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0007d	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00080	0f 87 17 0b 00
	00		 ja	 $LN499@inflate

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00086	8d 79 58	 lea	 edi, DWORD PTR [ecx+88]
  00089	89 7d d0	 mov	 DWORD PTR tv2812[ebp], edi

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  0008c	8d 79 5c	 lea	 edi, DWORD PTR [ecx+92]
  0008f	89 7d c0	 mov	 DWORD PTR tv2809[ebp], edi
  00092	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
$LL5@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00095	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN936@inflate[eax*4]
$LN335@inflate:

; 657  :         case HEAD:
; 658  :             if (state->wrap == 0) {

  0009c	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0009f	89 45 c8	 mov	 DWORD PTR tv2792[ebp], eax
  000a2	85 c0		 test	 eax, eax
  000a4	75 0c		 jne	 SHORT $LN12@inflate

; 659  :                 state->mode = TYPEDO;

  000a6	c7 41 04 40 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16192 ; 00003f40H

; 660  :                 break;

  000ad	e9 da 0a 00 00	 jmp	 $LN8@inflate
$LN12@inflate:

; 661  :             }
; 662  :             NEEDBITS(16);

  000b2	83 fe 10	 cmp	 esi, 16			; 00000010H
  000b5	73 2d		 jae	 SHORT $LN10@inflate
$LL13@inflate:
  000b7	85 db		 test	 ebx, ebx
  000b9	0f 84 ff 04 00
	00		 je	 $LN887@inflate
  000bf	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  000c2	8b ce		 mov	 ecx, esi
  000c4	d3 e0		 shl	 eax, cl
  000c6	83 c6 08	 add	 esi, 8
  000c9	4b		 dec	 ebx
  000ca	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  000cd	03 d0		 add	 edx, eax
  000cf	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  000d2	47		 inc	 edi
  000d3	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  000d6	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  000d9	83 fe 10	 cmp	 esi, 16			; 00000010H
  000dc	72 d9		 jb	 SHORT $LL13@inflate
  000de	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  000e1	8b 45 c8	 mov	 eax, DWORD PTR tv2792[ebp]
$LN10@inflate:

; 663  : #ifdef GUNZIP
; 664  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  000e4	a8 02		 test	 al, 2
  000e6	74 54		 je	 SHORT $LN338@inflate
  000e8	81 fa 1f 8b 00
	00		 cmp	 edx, 35615		; 00008b1fH
  000ee	75 4c		 jne	 SHORT $LN338@inflate

; 665  :                 if (state->wbits == 0)

  000f0	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  000f4	75 07		 jne	 SHORT $LN339@inflate

; 666  :                     state->wbits = 15;

  000f6	c7 41 28 0f 00
	00 00		 mov	 DWORD PTR [ecx+40], 15	; 0000000fH
$LN339@inflate:

; 667  :                 state->check = crc32(0L, Z_NULL, 0);

  000fd	6a 00		 push	 0
  000ff	6a 00		 push	 0
  00101	6a 00		 push	 0
  00103	e8 00 00 00 00	 call	 _crc32@12
  00108	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 668  :                 CRC2(state->check, hold);

  0010b	6a 02		 push	 2
  0010d	66 c7 45 e4 1f
	8b		 mov	 WORD PTR _hbuf$[ebp], 35615 ; 00008b1fH
  00113	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00116	8d 4d e4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00119	51		 push	 ecx
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _crc32@12
  00120	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 669  :                 INITBITS();

  00123	33 d2		 xor	 edx, edx
  00125	33 f6		 xor	 esi, esi
  00127	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0012a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0012d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 670  :                 state->mode = FLAGS;

  00130	c7 41 04 35 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16181 ; 00003f35H

; 671  :                 break;

  00137	e9 50 0a 00 00	 jmp	 $LN8@inflate
$LN338@inflate:

; 672  :             }
; 673  :             state->flags = 0;           /* expect zlib header */
; 674  :             if (state->head != Z_NULL)

  0013c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0013f	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  00146	85 c0		 test	 eax, eax
  00148	74 07		 je	 SHORT $LN340@inflate

; 675  :                 state->head->done = -1;

  0014a	c7 40 30 ff ff
	ff ff		 mov	 DWORD PTR [eax+48], -1
$LN340@inflate:

; 676  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */

  00151	f6 41 0c 01	 test	 BYTE PTR [ecx+12], 1
  00155	0f 84 cc 00 00
	00		 je	 $LN342@inflate
  0015b	0f b6 ca	 movzx	 ecx, dl
  0015e	8b c2		 mov	 eax, edx
  00160	c1 e1 08	 shl	 ecx, 8
  00163	33 d2		 xor	 edx, edx
  00165	c1 e8 08	 shr	 eax, 8
  00168	03 c1		 add	 eax, ecx
  0016a	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  0016f	f7 f1		 div	 ecx

; 687  :                 state->mode = BAD;

  00171	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00174	85 d2		 test	 edx, edx
  00176	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00179	0f 85 a8 00 00
	00		 jne	 $LN342@inflate

; 684  :             }
; 685  :             if (BITS(4) != Z_DEFLATED) {

  0017f	8b c2		 mov	 eax, edx
  00181	24 0f		 and	 al, 15			; 0000000fH
  00183	3c 08		 cmp	 al, 8
  00185	74 16		 je	 SHORT $LN26@inflate
$LN933@inflate:

; 686  :                 strm->msg = (char *)"unknown compression method";

  00187	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0018a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 687  :                 state->mode = BAD;

  00191	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 688  :                 break;

  00198	e9 ef 09 00 00	 jmp	 $LN8@inflate
$LN26@inflate:

; 689  :             }
; 690  :             DROPBITS(4);

  0019d	c1 ea 04	 shr	 edx, 4
  001a0	83 ee 04	 sub	 esi, 4

; 691  :             len = BITS(4) + 8;

  001a3	8b c2		 mov	 eax, edx
  001a5	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  001a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  001ab	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  001ae	83 c0 08	 add	 eax, 8

; 692  :             if (state->wbits == 0)

  001b1	83 79 28 00	 cmp	 DWORD PTR [ecx+40], 0
  001b5	89 45 c8	 mov	 DWORD PTR _len$1$[ebp], eax
  001b8	75 03		 jne	 SHORT $LN344@inflate

; 693  :                 state->wbits = len;

  001ba	89 41 28	 mov	 DWORD PTR [ecx+40], eax
$LN344@inflate:

; 694  :             if (len > 15 || len > state->wbits) {

  001bd	83 f8 0f	 cmp	 eax, 15			; 0000000fH
  001c0	77 4f		 ja	 SHORT $LN346@inflate
  001c2	3b 41 28	 cmp	 eax, DWORD PTR [ecx+40]
  001c5	77 4a		 ja	 SHORT $LN346@inflate

; 698  :             }
; 699  :             state->dmax = 1U << len;

  001c7	8b 4d c8	 mov	 ecx, DWORD PTR _len$1$[ebp]
  001ca	b8 01 00 00 00	 mov	 eax, 1
  001cf	d3 e0		 shl	 eax, cl
  001d1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 700  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 701  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001d4	6a 00		 push	 0
  001d6	6a 00		 push	 0
  001d8	6a 00		 push	 0
  001da	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  001dd	e8 00 00 00 00	 call	 _adler32@12
  001e2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  001e5	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001e8	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  001eb	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 702  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001ee	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  001f1	c1 ea 08	 shr	 edx, 8
  001f4	f7 d2		 not	 edx
  001f6	83 e2 02	 and	 edx, 2
  001f9	81 ca 3d 3f 00
	00		 or	 edx, 16189		; 00003f3dH
  001ff	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 703  :             INITBITS();

  00202	33 d2		 xor	 edx, edx
  00204	33 f6		 xor	 esi, esi
  00206	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00209	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 704  :             break;

  0020c	e9 7b 09 00 00	 jmp	 $LN8@inflate
$LN346@inflate:

; 695  :                 strm->msg = (char *)"invalid window size";

  00211	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00214	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 696  :                 state->mode = BAD;

  0021b	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 697  :                 break;

  00222	e9 65 09 00 00	 jmp	 $LN8@inflate
$LN342@inflate:

; 677  : #else
; 678  :             if (
; 679  : #endif
; 680  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {
; 681  :                 strm->msg = (char *)"incorrect header check";

  00227	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0022a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 682  :                 state->mode = BAD;

  00231	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H

; 683  :                 break;

  00238	e9 4f 09 00 00	 jmp	 $LN8@inflate
$LN32@inflate:

; 705  : #ifdef GUNZIP
; 706  :         case FLAGS:
; 707  :             NEEDBITS(16);

  0023d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00240	73 2a		 jae	 SHORT $LN30@inflate
$LL33@inflate:
  00242	85 db		 test	 ebx, ebx
  00244	0f 84 74 03 00
	00		 je	 $LN887@inflate
  0024a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0024d	8b ce		 mov	 ecx, esi
  0024f	d3 e0		 shl	 eax, cl
  00251	83 c6 08	 add	 esi, 8
  00254	4b		 dec	 ebx
  00255	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00258	03 d0		 add	 edx, eax
  0025a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0025d	47		 inc	 edi
  0025e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00261	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00264	83 fe 10	 cmp	 esi, 16			; 00000010H
  00267	72 d9		 jb	 SHORT $LL33@inflate
  00269	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN30@inflate:

; 708  :             state->flags = (int)(hold);

  0026c	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 709  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0026f	80 fa 08	 cmp	 dl, 8
  00272	0f 85 0f ff ff
	ff		 jne	 $LN933@inflate

; 710  :                 strm->msg = (char *)"unknown compression method";
; 711  :                 state->mode = BAD;
; 712  :                 break;
; 713  :             }
; 714  :             if (state->flags & 0xe000) {

  00278	f7 c2 00 e0 00
	00		 test	 edx, 57344		; 0000e000H
  0027e	74 16		 je	 SHORT $LN350@inflate

; 715  :                 strm->msg = (char *)"unknown header flags set";

  00280	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00283	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  0028a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00291	e9 f6 08 00 00	 jmp	 $LN8@inflate
$LN350@inflate:

; 716  :                 state->mode = BAD;
; 717  :                 break;
; 718  :             }
; 719  :             if (state->head != Z_NULL)

  00296	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  00299	85 f6		 test	 esi, esi
  0029b	74 0a		 je	 SHORT $LN351@inflate

; 720  :                 state->head->text = (int)((hold >> 8) & 1);

  0029d	8b c2		 mov	 eax, edx
  0029f	c1 e8 08	 shr	 eax, 8
  002a2	83 e0 01	 and	 eax, 1
  002a5	89 06		 mov	 DWORD PTR [esi], eax
$LN351@inflate:

; 721  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  002a7	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  002ae	74 23		 je	 SHORT $LN39@inflate
  002b0	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  002b4	74 1d		 je	 SHORT $LN39@inflate

; 722  :                 CRC2(state->check, hold);

  002b6	6a 02		 push	 2
  002b8	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  002bb	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  002be	50		 push	 eax
  002bf	ff 71 1c	 push	 DWORD PTR [ecx+28]
  002c2	c1 ea 08	 shr	 edx, 8
  002c5	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  002c8	e8 00 00 00 00	 call	 _crc32@12
  002cd	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  002d0	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN39@inflate:

; 723  :             INITBITS();

  002d3	33 d2		 xor	 edx, edx

; 724  :             state->mode = TIME;

  002d5	c7 41 04 36 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16182 ; 00003f36H
  002dc	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  002df	33 f6		 xor	 esi, esi

; 725  :         case TIME:
; 726  :             NEEDBITS(32);

  002e1	eb 05		 jmp	 SHORT $LL47@inflate
$LN46@inflate:
  002e3	83 fe 20	 cmp	 esi, 32			; 00000020H
  002e6	73 27		 jae	 SHORT $LN44@inflate
$LL47@inflate:
  002e8	85 db		 test	 ebx, ebx
  002ea	0f 84 ce 02 00
	00		 je	 $LN887@inflate
  002f0	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  002f3	8b ce		 mov	 ecx, esi
  002f5	d3 e0		 shl	 eax, cl
  002f7	4b		 dec	 ebx
  002f8	03 d0		 add	 edx, eax
  002fa	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  002fd	47		 inc	 edi
  002fe	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00301	83 c6 08	 add	 esi, 8
  00304	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00307	83 fe 20	 cmp	 esi, 32			; 00000020H
  0030a	72 dc		 jb	 SHORT $LL47@inflate
  0030c	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN44@inflate:

; 727  :             if (state->head != Z_NULL)

  0030f	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00312	85 c0		 test	 eax, eax
  00314	74 03		 je	 SHORT $LN355@inflate

; 728  :                 state->head->time = hold;

  00316	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN355@inflate:

; 729  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  00319	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00320	74 33		 je	 SHORT $LN53@inflate
  00322	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00326	74 2d		 je	 SHORT $LN53@inflate

; 730  :                 CRC4(state->check, hold);

  00328	8b c2		 mov	 eax, edx
  0032a	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0032d	c1 e8 08	 shr	 eax, 8
  00330	88 45 e5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00333	8b c2		 mov	 eax, edx
  00335	c1 e8 10	 shr	 eax, 16			; 00000010H
  00338	88 45 e6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0033b	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0033e	6a 04		 push	 4
  00340	50		 push	 eax
  00341	ff 71 1c	 push	 DWORD PTR [ecx+28]
  00344	c1 ea 18	 shr	 edx, 24			; 00000018H
  00347	88 55 e7	 mov	 BYTE PTR _hbuf$[ebp+3], dl
  0034a	e8 00 00 00 00	 call	 _crc32@12
  0034f	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00352	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN53@inflate:

; 731  :             INITBITS();

  00355	33 d2		 xor	 edx, edx

; 732  :             state->mode = OS;

  00357	c7 41 04 37 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16183 ; 00003f37H
  0035e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00361	33 f6		 xor	 esi, esi

; 733  :         case OS:
; 734  :             NEEDBITS(16);

  00363	eb 0b		 jmp	 SHORT $LL61@inflate
$LN60@inflate:
  00365	83 fe 10	 cmp	 esi, 16			; 00000010H
  00368	73 2d		 jae	 SHORT $LN58@inflate
  0036a	66 0f 1f 44 00
	00		 npad	 6
$LL61@inflate:
  00370	85 db		 test	 ebx, ebx
  00372	0f 84 46 02 00
	00		 je	 $LN887@inflate
  00378	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0037b	8b ce		 mov	 ecx, esi
  0037d	d3 e0		 shl	 eax, cl
  0037f	4b		 dec	 ebx
  00380	03 d0		 add	 edx, eax
  00382	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00385	47		 inc	 edi
  00386	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00389	83 c6 08	 add	 esi, 8
  0038c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0038f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00392	72 dc		 jb	 SHORT $LL61@inflate
  00394	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN58@inflate:

; 735  :             if (state->head != Z_NULL) {

  00397	8b 71 24	 mov	 esi, DWORD PTR [ecx+36]
  0039a	85 f6		 test	 esi, esi
  0039c	74 17		 je	 SHORT $LN359@inflate

; 736  :                 state->head->xflags = (int)(hold & 0xff);

  0039e	0f b6 c2	 movzx	 eax, dl

; 737  :                 state->head->os = (int)(hold >> 8);

  003a1	8b ca		 mov	 ecx, edx
  003a3	89 46 08	 mov	 DWORD PTR [esi+8], eax
  003a6	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  003a9	c1 e9 08	 shr	 ecx, 8
  003ac	8b 40 24	 mov	 eax, DWORD PTR [eax+36]
  003af	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  003b2	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN359@inflate:

; 738  :             }
; 739  :             if ((state->flags & 0x0200) && (state->wrap & 4))

  003b5	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  003bc	74 23		 je	 SHORT $LN67@inflate
  003be	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  003c2	74 1d		 je	 SHORT $LN67@inflate

; 740  :                 CRC2(state->check, hold);

  003c4	6a 02		 push	 2
  003c6	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  003c9	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  003cc	50		 push	 eax
  003cd	ff 71 1c	 push	 DWORD PTR [ecx+28]
  003d0	c1 ea 08	 shr	 edx, 8
  003d3	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  003d6	e8 00 00 00 00	 call	 _crc32@12
  003db	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  003de	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN67@inflate:

; 741  :             INITBITS();

  003e1	33 d2		 xor	 edx, edx

; 742  :             state->mode = EXLEN;

  003e3	c7 41 04 38 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16184 ; 00003f38H
  003ea	33 f6		 xor	 esi, esi
  003ec	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  003ef	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN361@inflate:

; 743  :         case EXLEN:
; 744  :             if (state->flags & 0x0400) {

  003f2	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  003f9	74 73		 je	 SHORT $LN362@inflate

; 745  :                 NEEDBITS(16);

  003fb	83 fe 10	 cmp	 esi, 16			; 00000010H
  003fe	73 27		 jae	 SHORT $LN72@inflate
$LL75@inflate:
  00400	85 db		 test	 ebx, ebx
  00402	0f 84 b6 01 00
	00		 je	 $LN887@inflate
  00408	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0040b	8b ce		 mov	 ecx, esi
  0040d	d3 e0		 shl	 eax, cl
  0040f	4b		 dec	 ebx
  00410	03 d0		 add	 edx, eax
  00412	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00415	47		 inc	 edi
  00416	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00419	83 c6 08	 add	 esi, 8
  0041c	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0041f	83 fe 10	 cmp	 esi, 16			; 00000010H
  00422	72 dc		 jb	 SHORT $LL75@inflate
  00424	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN72@inflate:

; 746  :                 state->length = (unsigned)(hold);
; 747  :                 if (state->head != Z_NULL)

  00427	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0042a	89 51 44	 mov	 DWORD PTR [ecx+68], edx
  0042d	85 c0		 test	 eax, eax
  0042f	74 03		 je	 SHORT $LN365@inflate

; 748  :                     state->head->extra_len = (unsigned)hold;

  00431	89 50 14	 mov	 DWORD PTR [eax+20], edx
$LN365@inflate:

; 749  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00434	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0043b	74 23		 je	 SHORT $LN81@inflate
  0043d	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00441	74 1d		 je	 SHORT $LN81@inflate

; 750  :                     CRC2(state->check, hold);

  00443	6a 02		 push	 2
  00445	8d 45 e4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  00448	88 55 e4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0044b	50		 push	 eax
  0044c	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0044f	c1 ea 08	 shr	 edx, 8
  00452	88 55 e5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00455	e8 00 00 00 00	 call	 _crc32@12
  0045a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0045d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN81@inflate:

; 751  :                 INITBITS();

  00460	33 f6		 xor	 esi, esi
  00462	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00469	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 752  :             }

  0046c	eb 0e		 jmp	 SHORT $LN367@inflate
$LN362@inflate:

; 753  :             else if (state->head != Z_NULL)

  0046e	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00471	85 c0		 test	 eax, eax
  00473	74 07		 je	 SHORT $LN367@inflate

; 754  :                 state->head->extra = Z_NULL;

  00475	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN367@inflate:

; 755  :             state->mode = EXTRA;

  0047c	c7 41 04 39 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16185 ; 00003f39H
$LN368@inflate:

; 756  :         case EXTRA:
; 757  :             if (state->flags & 0x0400) {

  00483	f7 41 14 00 04
	00 00		 test	 DWORD PTR [ecx+20], 1024 ; 00000400H
  0048a	0f 84 93 00 00
	00		 je	 $LN374@inflate

; 758  :                 copy = state->length;

  00490	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 759  :                 if (copy > have) copy = have;

  00493	3b c3		 cmp	 eax, ebx
  00495	8b d0		 mov	 edx, eax
  00497	89 45 cc	 mov	 DWORD PTR _copy$1$[ebp], eax
  0049a	0f 47 d3	 cmova	 edx, ebx
  0049d	89 55 c8	 mov	 DWORD PTR _copy$2$[ebp], edx

; 760  :                 if (copy) {

  004a0	85 d2		 test	 edx, edx
  004a2	74 75		 je	 SHORT $LN371@inflate

; 761  :                     if (state->head != Z_NULL &&

  004a4	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  004a7	85 c0		 test	 eax, eax
  004a9	74 3f		 je	 SHORT $LN372@inflate
  004ab	8b 78 10	 mov	 edi, DWORD PTR [eax+16]
  004ae	85 ff		 test	 edi, edi
  004b0	89 7d f4	 mov	 DWORD PTR tv2746[ebp], edi
  004b3	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  004b6	74 32		 je	 SHORT $LN372@inflate

; 762  :                         state->head->extra != Z_NULL) {
; 763  :                         len = state->head->extra_len - state->length;

  004b8	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004bb	2b 4d cc	 sub	 ecx, DWORD PTR _copy$1$[ebp]
  004be	89 4d d8	 mov	 DWORD PTR _len$2$[ebp], ecx

; 764  :                         zmemcpy(state->head->extra + len, next,

  004c1	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  004c4	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004c7	03 c2		 add	 eax, edx
  004c9	3b c1		 cmp	 eax, ecx
  004cb	8b 45 d8	 mov	 eax, DWORD PTR _len$2$[ebp]
  004ce	76 04		 jbe	 SHORT $LN509@inflate
  004d0	2b c8		 sub	 ecx, eax
  004d2	eb 02		 jmp	 SHORT $LN510@inflate
$LN509@inflate:
  004d4	8b ca		 mov	 ecx, edx
$LN510@inflate:
  004d6	03 45 f4	 add	 eax, DWORD PTR tv2746[ebp]
  004d9	51		 push	 ecx
  004da	57		 push	 edi
  004db	50		 push	 eax
  004dc	e8 00 00 00 00	 call	 _memcpy
  004e1	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  004e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  004e7	8b 55 c8	 mov	 edx, DWORD PTR _copy$2$[ebp]
$LN372@inflate:

; 765  :                                 len + copy > state->head->extra_max ?
; 766  :                                 state->head->extra_max - len : copy);
; 767  :                     }
; 768  :                     if ((state->flags & 0x0200) && (state->wrap & 4))

  004ea	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  004f1	74 16		 je	 SHORT $LN373@inflate
  004f3	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  004f7	74 10		 je	 SHORT $LN373@inflate

; 769  :                         state->check = crc32(state->check, next, copy);

  004f9	52		 push	 edx
  004fa	57		 push	 edi
  004fb	ff 71 1c	 push	 DWORD PTR [ecx+28]
  004fe	e8 00 00 00 00	 call	 _crc32@12
  00503	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00506	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
$LN373@inflate:

; 770  :                     have -= copy;

  00509	8b 45 c8	 mov	 eax, DWORD PTR _copy$2$[ebp]
  0050c	2b d8		 sub	 ebx, eax

; 771  :                     next += copy;

  0050e	03 f8		 add	 edi, eax
  00510	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 772  :                     state->length -= copy;

  00513	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00516	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
$LN371@inflate:

; 773  :                 }
; 774  :                 if (state->length) goto inf_leave;

  00519	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0051d	0f 85 9b 00 00
	00		 jne	 $LN887@inflate
$LN374@inflate:

; 775  :             }
; 776  :             state->length = 0;

  00523	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 777  :             state->mode = NAME;

  0052a	c7 41 04 3a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16186 ; 00003f3aH
$LN375@inflate:

; 778  :         case NAME:
; 779  :             if (state->flags & 0x0800) {

  00531	f7 41 14 00 08
	00 00		 test	 DWORD PTR [ecx+20], 2048 ; 00000800H
  00538	0f 84 09 01 00
	00		 je	 $LN376@inflate

; 780  :                 if (have == 0) goto inf_leave;

  0053e	85 db		 test	 ebx, ebx
  00540	74 7c		 je	 SHORT $LN887@inflate

; 781  :                 copy = 0;

  00542	33 d2		 xor	 edx, edx
$LL88@inflate:

; 782  :                 do {
; 783  :                     len = (unsigned)(next[copy++]);

  00544	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00548	42		 inc	 edx
  00549	89 45 d8	 mov	 DWORD PTR _len$3$[ebp], eax

; 784  :                     if (state->head != Z_NULL &&
; 785  :                             state->head->name != Z_NULL &&

  0054c	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0054f	85 c0		 test	 eax, eax
  00551	74 23		 je	 SHORT $LN86@inflate
  00553	8b 70 1c	 mov	 esi, DWORD PTR [eax+28]
  00556	89 75 cc	 mov	 DWORD PTR tv2744[ebp], esi
  00559	85 f6		 test	 esi, esi
  0055b	74 19		 je	 SHORT $LN86@inflate
  0055d	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  00560	3b 70 20	 cmp	 esi, DWORD PTR [eax+32]
  00563	73 11		 jae	 SHORT $LN86@inflate

; 786  :                             state->length < state->head->name_max)
; 787  :                         state->head->name[state->length++] = (Bytef)len;

  00565	8b 5d d8	 mov	 ebx, DWORD PTR _len$3$[ebp]
  00568	8b c6		 mov	 eax, esi
  0056a	8b 75 cc	 mov	 esi, DWORD PTR tv2744[ebp]
  0056d	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  00570	ff 41 44	 inc	 DWORD PTR [ecx+68]
  00573	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN86@inflate:

; 788  :                 } while (len && copy < have);

  00576	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
  00579	85 c0		 test	 eax, eax
  0057b	74 04		 je	 SHORT $LN380@inflate
  0057d	3b d3		 cmp	 edx, ebx
  0057f	72 c3		 jb	 SHORT $LL88@inflate
$LN380@inflate:

; 789  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  00581	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  00588	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  0058b	89 55 c8	 mov	 DWORD PTR _copy$3$[ebp], edx
  0058e	74 1c		 je	 SHORT $LN381@inflate
  00590	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00594	74 16		 je	 SHORT $LN381@inflate

; 790  :                     state->check = crc32(state->check, next, copy);

  00596	52		 push	 edx
  00597	57		 push	 edi
  00598	ff 71 1c	 push	 DWORD PTR [ecx+28]
  0059b	e8 00 00 00 00	 call	 _crc32@12
  005a0	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  005a3	8b 55 c8	 mov	 edx, DWORD PTR _copy$3$[ebp]
  005a6	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  005a9	8b 45 d8	 mov	 eax, DWORD PTR _len$3$[ebp]
$LN381@inflate:

; 791  :                 have -= copy;

  005ac	2b da		 sub	 ebx, edx

; 792  :                 next += copy;

  005ae	03 fa		 add	 edi, edx
  005b0	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  005b3	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 793  :                 if (len) goto inf_leave;

  005b6	85 c0		 test	 eax, eax
  005b8	0f 84 97 00 00
	00		 je	 $LN383@inflate
$LN887@inflate:
  005be	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
$LN897@inflate:
  005c1	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
$inf_leave$938:

; 1245 :         }
; 1246 : 
; 1247 :     /*
; 1248 :        Return from inflate(), updating the total counts and the check value.
; 1249 :        If there was no progress during the inflate() call, return a buffer
; 1250 :        error.  Call updatewindow() to create and/or update the window state.
; 1251 :        Note: a memory error from inflate() is non-recoverable.
; 1252 :      */
; 1253 :   inf_leave:
; 1254 :     RESTORE();

  005c4	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  005c7	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  005ca	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  005cd	89 4f 0c	 mov	 DWORD PTR [edi+12], ecx
  005d0	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  005d3	89 4f 10	 mov	 DWORD PTR [edi+16], ecx
  005d6	8b 4d f0	 mov	 ecx, DWORD PTR _next$1$[ebp]
  005d9	89 47 04	 mov	 DWORD PTR [edi+4], eax
  005dc	8b 45 fc	 mov	 eax, DWORD PTR _hold$1$[ebp]
  005df	89 0f		 mov	 DWORD PTR [edi], ecx

; 1255 :     if (state->wsize || (out != strm->avail_out && state->mode < BAD &&

  005e1	83 7b 2c 00	 cmp	 DWORD PTR [ebx+44], 0
  005e5	89 73 40	 mov	 DWORD PTR [ebx+64], esi
  005e8	8b 75 dc	 mov	 esi, DWORD PTR _out$1$[ebp]
  005eb	89 43 3c	 mov	 DWORD PTR [ebx+60], eax
  005ee	75 27		 jne	 SHORT $LN502@inflate
  005f0	3b 77 10	 cmp	 esi, DWORD PTR [edi+16]
  005f3	0f 84 17 10 00
	00		 je	 $LN503@inflate
  005f9	8b 43 04	 mov	 eax, DWORD PTR [ebx+4]
  005fc	3d 51 3f 00 00	 cmp	 eax, 16209		; 00003f51H
  00601	0f 8d 09 10 00
	00		 jge	 $LN503@inflate
  00607	3d 4e 3f 00 00	 cmp	 eax, 16206		; 00003f4eH
  0060c	7c 09		 jl	 SHORT $LN502@inflate
  0060e	83 fa 04	 cmp	 edx, 4
  00611	0f 84 f9 0f 00
	00		 je	 $LN503@inflate
$LN502@inflate:

; 1256 :             (state->mode < CHECK || flush != Z_FINISH)))
; 1257 :         if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {

  00617	8b 57 0c	 mov	 edx, DWORD PTR [edi+12]
  0061a	8b c6		 mov	 eax, esi
  0061c	2b 47 10	 sub	 eax, DWORD PTR [edi+16]
  0061f	8b cf		 mov	 ecx, edi
  00621	50		 push	 eax
  00622	e8 00 00 00 00	 call	 _updatewindow
  00627	83 c4 04	 add	 esp, 4
  0062a	85 c0		 test	 eax, eax
  0062c	0f 84 de 0f 00
	00		 je	 $LN503@inflate

; 1258 :             state->mode = MEM;

  00632	c7 43 04 52 3f
	00 00		 mov	 DWORD PTR [ebx+4], 16210 ; 00003f52H
$LN498@inflate:
  00639	5f		 pop	 edi
  0063a	5e		 pop	 esi

; 1259 :             return Z_MEM_ERROR;

  0063b	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00640	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  00641	8b e5		 mov	 esp, ebp
  00643	5d		 pop	 ebp
  00644	c2 08 00	 ret	 8
$LN376@inflate:

; 794  :             }
; 795  :             else if (state->head != Z_NULL)

  00647	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0064a	85 c0		 test	 eax, eax
  0064c	74 07		 je	 SHORT $LN383@inflate

; 796  :                 state->head->name = Z_NULL;

  0064e	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN383@inflate:

; 797  :             state->length = 0;

  00655	c7 41 44 00 00
	00 00		 mov	 DWORD PTR [ecx+68], 0

; 798  :             state->mode = COMMENT;

  0065c	c7 41 04 3b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16187 ; 00003f3bH
$LN384@inflate:

; 799  :         case COMMENT:
; 800  :             if (state->flags & 0x1000) {

  00663	f7 41 14 00 10
	00 00		 test	 DWORD PTR [ecx+20], 4096 ; 00001000H
  0066a	0f 84 8c 00 00
	00		 je	 $LN385@inflate

; 801  :                 if (have == 0) goto inf_leave;

  00670	85 db		 test	 ebx, ebx
  00672	0f 84 46 ff ff
	ff		 je	 $LN887@inflate

; 802  :                 copy = 0;

  00678	33 d2		 xor	 edx, edx
  0067a	66 0f 1f 44 00
	00		 npad	 6
$LL91@inflate:

; 803  :                 do {
; 804  :                     len = (unsigned)(next[copy++]);

  00680	0f b6 04 3a	 movzx	 eax, BYTE PTR [edx+edi]
  00684	42		 inc	 edx
  00685	89 45 d8	 mov	 DWORD PTR _len$4$[ebp], eax

; 805  :                     if (state->head != Z_NULL &&
; 806  :                             state->head->comment != Z_NULL &&

  00688	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  0068b	85 c0		 test	 eax, eax
  0068d	74 23		 je	 SHORT $LN89@inflate
  0068f	8b 70 24	 mov	 esi, DWORD PTR [eax+36]
  00692	89 75 cc	 mov	 DWORD PTR tv2743[ebp], esi
  00695	85 f6		 test	 esi, esi
  00697	74 19		 je	 SHORT $LN89@inflate
  00699	8b 71 44	 mov	 esi, DWORD PTR [ecx+68]
  0069c	3b 70 28	 cmp	 esi, DWORD PTR [eax+40]
  0069f	73 11		 jae	 SHORT $LN89@inflate

; 807  :                             state->length < state->head->comm_max)
; 808  :                         state->head->comment[state->length++] = (Bytef)len;

  006a1	8b 5d d8	 mov	 ebx, DWORD PTR _len$4$[ebp]
  006a4	8b c6		 mov	 eax, esi
  006a6	8b 75 cc	 mov	 esi, DWORD PTR tv2743[ebp]
  006a9	88 1c 06	 mov	 BYTE PTR [esi+eax], bl
  006ac	ff 41 44	 inc	 DWORD PTR [ecx+68]
  006af	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN89@inflate:

; 809  :                 } while (len && copy < have);

  006b2	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
  006b5	85 c0		 test	 eax, eax
  006b7	74 04		 je	 SHORT $LN389@inflate
  006b9	3b d3		 cmp	 edx, ebx
  006bb	72 c3		 jb	 SHORT $LL91@inflate
$LN389@inflate:

; 810  :                 if ((state->flags & 0x0200) && (state->wrap & 4))

  006bd	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  006c4	8b 75 ec	 mov	 esi, DWORD PTR _bits$1$[ebp]
  006c7	89 55 c8	 mov	 DWORD PTR _copy$4$[ebp], edx
  006ca	74 1c		 je	 SHORT $LN390@inflate
  006cc	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  006d0	74 16		 je	 SHORT $LN390@inflate

; 811  :                     state->check = crc32(state->check, next, copy);

  006d2	52		 push	 edx
  006d3	57		 push	 edi
  006d4	ff 71 1c	 push	 DWORD PTR [ecx+28]
  006d7	e8 00 00 00 00	 call	 _crc32@12
  006dc	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  006df	8b 55 c8	 mov	 edx, DWORD PTR _copy$4$[ebp]
  006e2	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  006e5	8b 45 d8	 mov	 eax, DWORD PTR _len$4$[ebp]
$LN390@inflate:

; 812  :                 have -= copy;

  006e8	2b da		 sub	 ebx, edx

; 813  :                 next += copy;

  006ea	03 fa		 add	 edi, edx
  006ec	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  006ef	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 814  :                 if (len) goto inf_leave;

  006f2	85 c0		 test	 eax, eax
  006f4	0f 85 c4 fe ff
	ff		 jne	 $LN887@inflate

; 815  :             }

  006fa	eb 0e		 jmp	 SHORT $LN392@inflate
$LN385@inflate:

; 816  :             else if (state->head != Z_NULL)

  006fc	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  006ff	85 c0		 test	 eax, eax
  00701	74 07		 je	 SHORT $LN392@inflate

; 817  :                 state->head->comment = Z_NULL;

  00703	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
$LN392@inflate:
  0070a	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 818  :             state->mode = HCRC;

  0070d	c7 41 04 3c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16188 ; 00003f3cH
$LN393@inflate:

; 819  :         case HCRC:
; 820  :             if (state->flags & 0x0200) {

  00714	f7 41 14 00 02
	00 00		 test	 DWORD PTR [ecx+20], 512	; 00000200H
  0071b	74 5f		 je	 SHORT $LN101@inflate

; 821  :                 NEEDBITS(16);

  0071d	83 fe 10	 cmp	 esi, 16			; 00000010H
  00720	73 2a		 jae	 SHORT $LN92@inflate
$LL95@inflate:
  00722	85 db		 test	 ebx, ebx
  00724	0f 84 94 fe ff
	ff		 je	 $LN887@inflate
  0072a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0072d	8b ce		 mov	 ecx, esi
  0072f	d3 e0		 shl	 eax, cl
  00731	83 c6 08	 add	 esi, 8
  00734	4b		 dec	 ebx
  00735	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00738	03 d0		 add	 edx, eax
  0073a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0073d	47		 inc	 edi
  0073e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00741	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00744	83 fe 10	 cmp	 esi, 16			; 00000010H
  00747	72 d9		 jb	 SHORT $LL95@inflate
  00749	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN92@inflate:

; 822  :                 if ((state->wrap & 4) && hold != (state->check & 0xffff)) {

  0074c	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  00750	74 1e		 je	 SHORT $LN102@inflate
  00752	0f b7 41 1c	 movzx	 eax, WORD PTR [ecx+28]
  00756	3b d0		 cmp	 edx, eax
  00758	74 16		 je	 SHORT $LN102@inflate

; 823  :                     strm->msg = (char *)"header crc mismatch";

  0075a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0075d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00764	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  0076b	e9 1c 04 00 00	 jmp	 $LN8@inflate
$LN102@inflate:

; 824  :                     state->mode = BAD;
; 825  :                     break;
; 826  :                 }
; 827  :                 INITBITS();

  00770	33 f6		 xor	 esi, esi
  00772	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  00779	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN101@inflate:

; 828  :             }
; 829  :             if (state->head != Z_NULL) {

  0077c	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0077f	85 d2		 test	 edx, edx
  00781	74 16		 je	 SHORT $LN397@inflate

; 830  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00783	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00786	c1 f8 09	 sar	 eax, 9
  00789	83 e0 01	 and	 eax, 1
  0078c	89 42 2c	 mov	 DWORD PTR [edx+44], eax

; 831  :                 state->head->done = 1;

  0078f	8b 41 24	 mov	 eax, DWORD PTR [ecx+36]
  00792	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN397@inflate:

; 832  :             }
; 833  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00799	6a 00		 push	 0
  0079b	6a 00		 push	 0
  0079d	6a 00		 push	 0
  0079f	e8 00 00 00 00	 call	 _crc32@12
  007a4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  007a7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  007aa	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  007ad	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 834  :             state->mode = TYPE;

  007b0	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 835  :             break;

  007b7	e9 cd 03 00 00	 jmp	 $LN888@inflate
$LN105@inflate:

; 836  : #endif
; 837  :         case DICTID:
; 838  :             NEEDBITS(32);

  007bc	83 fe 20	 cmp	 esi, 32			; 00000020H
  007bf	73 24		 jae	 SHORT $LN103@inflate
$LL106@inflate:
  007c1	85 db		 test	 ebx, ebx
  007c3	0f 84 f5 fd ff
	ff		 je	 $LN887@inflate
  007c9	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  007cc	8b ce		 mov	 ecx, esi
  007ce	d3 e0		 shl	 eax, cl
  007d0	4b		 dec	 ebx
  007d1	03 d0		 add	 edx, eax
  007d3	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  007d6	47		 inc	 edi
  007d7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  007da	83 c6 08	 add	 esi, 8
  007dd	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  007e0	83 fe 20	 cmp	 esi, 32			; 00000020H
  007e3	72 dc		 jb	 SHORT $LL106@inflate
$LN103@inflate:

; 839  :             strm->adler = state->check = ZSWAP32(hold);

  007e5	8b ca		 mov	 ecx, edx
  007e7	8b c2		 mov	 eax, edx
  007e9	c1 e0 10	 shl	 eax, 16			; 00000010H
  007ec	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  007f2	03 c8		 add	 ecx, eax
  007f4	8b c2		 mov	 eax, edx
  007f6	c1 e8 08	 shr	 eax, 8
  007f9	c1 e1 08	 shl	 ecx, 8
  007fc	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00801	c1 ea 18	 shr	 edx, 24			; 00000018H
  00804	03 c1		 add	 eax, ecx
  00806	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00809	03 c2		 add	 eax, edx
  0080b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0080e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00811	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 840  :             INITBITS();

  00814	33 d2		 xor	 edx, edx
  00816	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00819	33 f6		 xor	 esi, esi

; 841  :             state->mode = DICT;

  0081b	c7 41 04 3e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16190 ; 00003f3eH
$LN400@inflate:

; 842  :         case DICT:
; 843  :             if (state->havedict == 0) {

  00822	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00826	0f 84 89 0d 00
	00		 je	 $LN586@inflate

; 846  :             }
; 847  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0082c	6a 00		 push	 0
  0082e	6a 00		 push	 0
  00830	6a 00		 push	 0
  00832	e8 00 00 00 00	 call	 _adler32@12
  00837	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0083a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0083d	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00840	89 42 30	 mov	 DWORD PTR [edx+48], eax
  00843	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 848  :             state->mode = TYPE;

  00846	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
$LN402@inflate:

; 849  :         case TYPE:
; 850  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;

  0084d	8b 45 0c	 mov	 eax, DWORD PTR _flush$[ebp]
  00850	83 f8 05	 cmp	 eax, 5
  00853	0f 84 65 fd ff
	ff		 je	 $LN887@inflate
  00859	83 f8 06	 cmp	 eax, 6
  0085c	0f 84 5c fd ff
	ff		 je	 $LN887@inflate
$LN403@inflate:

; 851  :         case TYPEDO:
; 852  :             if (state->last) {

  00862	83 79 08 00	 cmp	 DWORD PTR [ecx+8], 0
  00866	74 1e		 je	 SHORT $LN122@inflate

; 853  :                 BYTEBITS();

  00868	8b ce		 mov	 ecx, esi
  0086a	83 e1 07	 and	 ecx, 7
  0086d	d3 ea		 shr	 edx, cl
  0086f	2b f1		 sub	 esi, ecx

; 854  :                 state->mode = CHECK;

  00871	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00874	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00877	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0087a	c7 41 04 4e 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16206 ; 00003f4eH

; 855  :                 break;

  00881	e9 06 03 00 00	 jmp	 $LN8@inflate
$LN122@inflate:

; 856  :             }
; 857  :             NEEDBITS(3);

  00886	83 fe 03	 cmp	 esi, 3
  00889	73 2c		 jae	 SHORT $LN120@inflate
  0088b	0f 1f 44 00 00	 npad	 5
$LL123@inflate:
  00890	85 db		 test	 ebx, ebx
  00892	0f 84 26 fd ff
	ff		 je	 $LN887@inflate
  00898	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0089b	8b ce		 mov	 ecx, esi
  0089d	d3 e0		 shl	 eax, cl
  0089f	4b		 dec	 ebx
  008a0	03 d0		 add	 edx, eax
  008a2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  008a5	47		 inc	 edi
  008a6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008a9	83 c6 08	 add	 esi, 8
  008ac	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  008af	83 fe 03	 cmp	 esi, 3
  008b2	72 dc		 jb	 SHORT $LL123@inflate
  008b4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN120@inflate:

; 858  :             state->last = BITS(1);

  008b7	8b c2		 mov	 eax, edx

; 859  :             DROPBITS(1);

  008b9	d1 ea		 shr	 edx, 1
  008bb	83 e0 01	 and	 eax, 1
  008be	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 860  :             switch (BITS(2)) {

  008c1	8b c2		 mov	 eax, edx
  008c3	83 e0 03	 and	 eax, 3
  008c6	83 f8 03	 cmp	 eax, 3
  008c9	77 68		 ja	 SHORT $LN138@inflate
  008cb	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN937@inflate[eax*4]
$LN408@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  008d2	c1 ea 02	 shr	 edx, 2
  008d5	83 ee 03	 sub	 esi, 3
  008d8	c7 41 04 41 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16193 ; 00003f41H
  008df	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  008e2	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  008e5	e9 a2 02 00 00	 jmp	 $LN8@inflate
$LN409@inflate:

; 861  :             case 0:                             /* stored block */
; 862  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 863  :                         state->last ? " (last)" : ""));
; 864  :                 state->mode = STORED;
; 865  :                 break;
; 866  :             case 1:                             /* fixed block */
; 867  :                 fixedtables(state);

  008ea	e8 00 00 00 00	 call	 _fixedtables

; 868  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 869  :                         state->last ? " (last)" : ""));
; 870  :                 state->mode = LEN_;             /* decode codes */
; 871  :                 if (flush == Z_TREES) {

  008ef	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  008f3	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  008fa	75 37		 jne	 SHORT $LN138@inflate

; 872  :                     DROPBITS(2);

  008fc	c1 ea 02	 shr	 edx, 2
  008ff	83 ee 03	 sub	 esi, 3
  00902	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 873  :                     goto inf_leave;

  00905	e9 b4 fc ff ff	 jmp	 $LN887@inflate
$LN411@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  0090a	c1 ea 02	 shr	 edx, 2
  0090d	83 ee 03	 sub	 esi, 3
  00910	c7 41 04 44 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16196 ; 00003f44H
  00917	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0091a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  0091d	e9 6a 02 00 00	 jmp	 $LN8@inflate
$LN412@inflate:

; 874  :                 }
; 875  :                 break;
; 876  :             case 2:                             /* dynamic block */
; 877  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 878  :                         state->last ? " (last)" : ""));
; 879  :                 state->mode = TABLE;
; 880  :                 break;
; 881  :             case 3:
; 882  :                 strm->msg = (char *)"invalid block type";

  00922	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00925	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 883  :                 state->mode = BAD;

  0092c	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN138@inflate:

; 884  :             }
; 885  :             DROPBITS(2);

  00933	c1 ea 02	 shr	 edx, 2
  00936	83 ee 03	 sub	 esi, 3
  00939	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0093c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 886  :             break;

  0093f	e9 48 02 00 00	 jmp	 $LN8@inflate
$LN141@inflate:

; 887  :         case STORED:
; 888  :             BYTEBITS();                         /* go to byte boundary */

  00944	8b ce		 mov	 ecx, esi
  00946	83 e1 07	 and	 ecx, 7
  00949	2b f1		 sub	 esi, ecx
  0094b	d3 ea		 shr	 edx, cl
  0094d	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00950	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi

; 889  :             NEEDBITS(32);

  00953	83 fe 20	 cmp	 esi, 32			; 00000020H
  00956	73 27		 jae	 SHORT $LN142@inflate
$LL145@inflate:
  00958	85 db		 test	 ebx, ebx
  0095a	0f 84 5e fc ff
	ff		 je	 $LN887@inflate
  00960	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00963	8b ce		 mov	 ecx, esi
  00965	d3 e0		 shl	 eax, cl
  00967	83 c6 08	 add	 esi, 8
  0096a	4b		 dec	 ebx
  0096b	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  0096e	03 d0		 add	 edx, eax
  00970	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00973	47		 inc	 edi
  00974	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00977	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  0097a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0097d	72 d9		 jb	 SHORT $LL145@inflate
$LN142@inflate:

; 890  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0097f	8b c2		 mov	 eax, edx
  00981	0f b7 ca	 movzx	 ecx, dx
  00984	f7 d0		 not	 eax
  00986	89 4d c8	 mov	 DWORD PTR tv2736[ebp], ecx
  00989	c1 e8 10	 shr	 eax, 16			; 00000010H
  0098c	3b c8		 cmp	 ecx, eax

; 892  :                 state->mode = BAD;

  0098e	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00991	74 16		 je	 SHORT $LN415@inflate

; 891  :                 strm->msg = (char *)"invalid stored block lengths";

  00993	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00996	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  0099d	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  009a4	e9 e3 01 00 00	 jmp	 $LN8@inflate
$LN415@inflate:

; 893  :                 break;
; 894  :             }
; 895  :             state->length = (unsigned)hold & 0xffff;

  009a9	8b 45 c8	 mov	 eax, DWORD PTR tv2736[ebp]

; 896  :             Tracev((stderr, "inflate:       stored length %u\n",
; 897  :                     state->length));
; 898  :             INITBITS();

  009ac	33 d2		 xor	 edx, edx
  009ae	33 f6		 xor	 esi, esi
  009b0	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 899  :             state->mode = COPY_;
; 900  :             if (flush == Z_TREES) goto inf_leave;

  009b3	83 7d 0c 06	 cmp	 DWORD PTR _flush$[ebp], 6
  009b7	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  009ba	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  009bd	c7 41 04 42 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16194 ; 00003f42H
  009c4	0f 84 f4 fb ff
	ff		 je	 $LN887@inflate
$LN416@inflate:

; 901  :         case COPY_:
; 902  :             state->mode = COPY;

  009ca	c7 41 04 43 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16195 ; 00003f43H
$LN418@inflate:

; 903  :         case COPY:
; 904  :             copy = state->length;

  009d1	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]

; 905  :             if (copy) {

  009d4	85 c0		 test	 eax, eax
  009d6	0f 84 08 07 00
	00		 je	 $LN419@inflate

; 906  :                 if (copy > have) copy = have;

  009dc	3b c3		 cmp	 eax, ebx
  009de	0f 47 c3	 cmova	 eax, ebx

; 907  :                 if (copy > left) copy = left;

  009e1	3b 45 e8	 cmp	 eax, DWORD PTR _left$1$[ebp]
  009e4	0f 47 45 e8	 cmova	 eax, DWORD PTR _left$1$[ebp]
  009e8	89 45 c8	 mov	 DWORD PTR _copy$7$[ebp], eax

; 908  :                 if (copy == 0) goto inf_leave;

  009eb	85 c0		 test	 eax, eax
  009ed	0f 84 cb fb ff
	ff		 je	 $LN887@inflate

; 909  :                 zmemcpy(put, next, copy);

  009f3	50		 push	 eax
  009f4	57		 push	 edi
  009f5	ff 75 e0	 push	 DWORD PTR _put$1$[ebp]
  009f8	e8 00 00 00 00	 call	 _memcpy

; 910  :                 have -= copy;

  009fd	8b 45 c8	 mov	 eax, DWORD PTR _copy$7$[ebp]
  00a00	83 c4 0c	 add	 esp, 12			; 0000000cH

; 911  :                 next += copy;
; 912  :                 left -= copy;
; 913  :                 put += copy;
; 914  :                 state->length -= copy;

  00a03	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00a06	2b d8		 sub	 ebx, eax
  00a08	29 45 e8	 sub	 DWORD PTR _left$1$[ebp], eax
  00a0b	03 f8		 add	 edi, eax
  00a0d	01 45 e0	 add	 DWORD PTR _put$1$[ebp], eax
  00a10	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a13	29 41 44	 sub	 DWORD PTR [ecx+68], eax
  00a16	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi

; 915  :                 break;

  00a19	e9 6b 01 00 00	 jmp	 $LN888@inflate
$LN155@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       stored end\n"));
; 918  :             state->mode = TYPE;
; 919  :             break;
; 920  :         case TABLE:
; 921  :             NEEDBITS(14);

  00a1e	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a21	73 27		 jae	 SHORT $LN153@inflate
$LL156@inflate:
  00a23	85 db		 test	 ebx, ebx
  00a25	0f 84 93 fb ff
	ff		 je	 $LN887@inflate
  00a2b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00a2e	8b ce		 mov	 ecx, esi
  00a30	d3 e0		 shl	 eax, cl
  00a32	4b		 dec	 ebx
  00a33	03 d0		 add	 edx, eax
  00a35	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00a38	47		 inc	 edi
  00a39	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00a3c	83 c6 08	 add	 esi, 8
  00a3f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00a42	83 fe 0e	 cmp	 esi, 14			; 0000000eH
  00a45	72 dc		 jb	 SHORT $LL156@inflate
  00a47	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN153@inflate:

; 922  :             state->nlen = BITS(5) + 257;

  00a4a	8b c2		 mov	 eax, edx

; 923  :             DROPBITS(5);
; 924  :             state->ndist = BITS(5) + 1;
; 925  :             DROPBITS(5);
; 926  :             state->ncode = BITS(4) + 4;
; 927  :             DROPBITS(4);

  00a4c	83 ee 0e	 sub	 esi, 14			; 0000000eH
  00a4f	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a52	c1 ea 05	 shr	 edx, 5
  00a55	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00a5a	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00a5d	89 41 64	 mov	 DWORD PTR [ecx+100], eax
  00a60	8b c2		 mov	 eax, edx
  00a62	83 e0 1f	 and	 eax, 31			; 0000001fH
  00a65	c1 ea 05	 shr	 edx, 5
  00a68	40		 inc	 eax
  00a69	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00a6c	8b c2		 mov	 eax, edx
  00a6e	83 e0 0f	 and	 eax, 15			; 0000000fH
  00a71	c1 ea 04	 shr	 edx, 4
  00a74	83 c0 04	 add	 eax, 4
  00a77	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx

; 928  : #ifndef PKZIP_BUG_WORKAROUND
; 929  :             if (state->nlen > 286 || state->ndist > 30) {

  00a7a	81 79 64 1e 01
	00 00		 cmp	 DWORD PTR [ecx+100], 286 ; 0000011eH
  00a81	89 41 60	 mov	 DWORD PTR [ecx+96], eax
  00a84	0f 87 21 01 00
	00		 ja	 $LN426@inflate
  00a8a	83 79 68 1e	 cmp	 DWORD PTR [ecx+104], 30	; 0000001eH
  00a8e	0f 87 17 01 00
	00		 ja	 $LN426@inflate

; 931  :                 state->mode = BAD;
; 932  :                 break;
; 933  :             }
; 934  : #endif
; 935  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 936  :             state->have = 0;

  00a94	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 937  :             state->mode = LENLENS;

  00a9b	c7 41 04 45 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16197 ; 00003f45H
$LN532@inflate:

; 938  :         case LENLENS:
; 939  :             while (state->have < state->ncode) {

  00aa2	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00aa5	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00aa8	73 66		 jae	 SHORT $LN534@inflate
  00aaa	66 0f 1f 44 00
	00		 npad	 6
$LL170@inflate:

; 940  :                 NEEDBITS(3);

  00ab0	83 fe 03	 cmp	 esi, 3
  00ab3	73 24		 jae	 SHORT $LN172@inflate
$LL175@inflate:
  00ab5	85 db		 test	 ebx, ebx
  00ab7	0f 84 01 fb ff
	ff		 je	 $LN887@inflate
  00abd	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00ac0	8b ce		 mov	 ecx, esi
  00ac2	d3 e0		 shl	 eax, cl
  00ac4	4b		 dec	 ebx
  00ac5	03 d0		 add	 edx, eax
  00ac7	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00aca	47		 inc	 edi
  00acb	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00ace	83 c6 08	 add	 esi, 8
  00ad1	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00ad4	83 fe 03	 cmp	 esi, 3
  00ad7	72 dc		 jb	 SHORT $LL175@inflate
$LN172@inflate:

; 941  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ad9	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00adc	8b ca		 mov	 ecx, edx
  00ade	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00ae1	83 e1 07	 and	 ecx, 7

; 942  :                 DROPBITS(3);

  00ae4	c1 ea 03	 shr	 edx, 3
  00ae7	83 ee 03	 sub	 esi, 3
  00aea	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00aed	8b 40 6c	 mov	 eax, DWORD PTR [eax+108]
  00af0	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00af3	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00afb	66 89 4c 47 74	 mov	 WORD PTR [edi+eax*2+116], cx
  00b00	8b cf		 mov	 ecx, edi
  00b02	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00b05	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b08	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b0b	3b 41 60	 cmp	 eax, DWORD PTR [ecx+96]
  00b0e	72 a0		 jb	 SHORT $LL170@inflate
$LN534@inflate:

; 943  :             }
; 944  :             while (state->have < 19)

  00b10	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b14	73 25		 jae	 SHORT $LN184@inflate
  00b16	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL183@inflate:

; 945  :                 state->lens[order[state->have++]] = 0;

  00b20	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00b23	33 d2		 xor	 edx, edx
  00b25	0f b7 04 45 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[eax*2]
  00b2d	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00b32	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00b35	83 79 6c 13	 cmp	 DWORD PTR [ecx+108], 19	; 00000013H
  00b39	72 e5		 jb	 SHORT $LL183@inflate
$LN184@inflate:

; 946  :             state->next = state->codes;
; 947  :             state->lencode = (const code FAR *)(state->next);

  00b3b	8b 55 f8	 mov	 edx, DWORD PTR _state$1$[ebp]
  00b3e	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00b44	83 c1 70	 add	 ecx, 112		; 00000070H
  00b47	89 42 50	 mov	 DWORD PTR [edx+80], eax
  00b4a	89 01		 mov	 DWORD PTR [ecx], eax

; 948  :             state->lenbits = 7;
; 949  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),

  00b4c	8d 82 f4 02 00
	00		 lea	 eax, DWORD PTR [edx+756]
  00b52	50		 push	 eax
  00b53	8d 42 58	 lea	 eax, DWORD PTR [edx+88]
  00b56	c7 42 58 07 00
	00 00		 mov	 DWORD PTR [edx+88], 7
  00b5d	50		 push	 eax
  00b5e	51		 push	 ecx
  00b5f	6a 13		 push	 19			; 00000013H
  00b61	83 c2 74	 add	 edx, 116		; 00000074H
  00b64	33 c9		 xor	 ecx, ecx
  00b66	e8 00 00 00 00	 call	 _inflate_table

; 953  :                 state->mode = BAD;

  00b6b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00b6e	83 c4 10	 add	 esp, 16			; 00000010H
  00b71	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00b74	85 c0		 test	 eax, eax
  00b76	74 46		 je	 SHORT $LN429@inflate

; 950  :                                 &(state->lenbits), state->work);
; 951  :             if (ret) {
; 952  :                 strm->msg = (char *)"invalid code lengths set";

  00b78	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b7b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
$LN932@inflate:

; 1013 :                 state->mode = BAD;

  00b82	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
$LN888@inflate:
  00b89	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN8@inflate:

; 655  :     for (;;)
; 656  :         switch (state->mode) {

  00b8c	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00b8f	2d 34 3f 00 00	 sub	 eax, 16180		; 00003f34H
  00b94	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00b97	0f 86 f8 f4 ff
	ff		 jbe	 $LL5@inflate
$LN499@inflate:
  00b9d	5f		 pop	 edi
  00b9e	5e		 pop	 esi

; 1239 :             goto inf_leave;
; 1240 :         case MEM:
; 1241 :             return Z_MEM_ERROR;
; 1242 :         case SYNC:
; 1243 :         default:
; 1244 :             return Z_STREAM_ERROR;

  00b9f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00ba4	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  00ba5	8b e5		 mov	 esp, ebp
  00ba7	5d		 pop	 ebp
  00ba8	c2 08 00	 ret	 8
$LN426@inflate:

; 930  :                 strm->msg = (char *)"too many length or distance symbols";

  00bab	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00bae	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00bb5	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00bbc	eb ce		 jmp	 SHORT $LN8@inflate
$LN429@inflate:

; 954  :                 break;
; 955  :             }
; 956  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 957  :             state->have = 0;

  00bbe	c7 41 6c 00 00
	00 00		 mov	 DWORD PTR [ecx+108], 0

; 958  :             state->mode = CODELENS;

  00bc5	c7 41 04 46 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16198 ; 00003f46H
$LN535@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00bcc	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00bcf	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00bd2	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00bd5	89 55 d8	 mov	 DWORD PTR tv2728[ebp], edx
  00bd8	3b d0		 cmp	 edx, eax
  00bda	0f 83 0a 02 00
	00		 jae	 $LN186@inflate
$LL185@inflate:

; 961  :                 for (;;) {
; 962  :                     here = state->lencode[BITS(state->lenbits)];

  00be0	8b 45 d0	 mov	 eax, DWORD PTR tv2812[ebp]
  00be3	ba 01 00 00 00	 mov	 edx, 1
  00be8	8b 08		 mov	 ecx, DWORD PTR [eax]
  00bea	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00bed	d3 e2		 shl	 edx, cl
  00bef	4a		 dec	 edx
  00bf0	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00bf3	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00bf6	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]

; 963  :                     if ((unsigned)(here.bits) <= bits) break;

  00bf9	8b c8		 mov	 ecx, eax
  00bfb	c1 e9 08	 shr	 ecx, 8
  00bfe	0f b6 c9	 movzx	 ecx, cl
  00c01	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00c04	3b ce		 cmp	 ecx, esi
  00c06	76 45		 jbe	 SHORT $LN562@inflate
$LL187@inflate:

; 964  :                     PULLBYTE();

  00c08	85 db		 test	 ebx, ebx
  00c0a	0f 84 ae f9 ff
	ff		 je	 $LN887@inflate
  00c10	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00c13	8b ce		 mov	 ecx, esi
  00c15	d3 e0		 shl	 eax, cl
  00c17	ba 01 00 00 00	 mov	 edx, 1
  00c1c	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  00c1f	4b		 dec	 ebx
  00c20	8b 45 d0	 mov	 eax, DWORD PTR tv2812[ebp]
  00c23	47		 inc	 edi
  00c24	83 c6 08	 add	 esi, 8
  00c27	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00c2a	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00c2d	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c2f	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00c32	d3 e2		 shl	 edx, cl
  00c34	4a		 dec	 edx
  00c35	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00c38	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00c3b	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00c3e	8b c8		 mov	 ecx, eax
  00c40	c1 e9 08	 shr	 ecx, 8
  00c43	0f b6 c9	 movzx	 ecx, cl
  00c46	89 45 c8	 mov	 DWORD PTR _here$[ebp], eax
  00c49	3b ce		 cmp	 ecx, esi
  00c4b	77 bb		 ja	 SHORT $LL187@inflate
$LN562@inflate:

; 965  :                 }
; 966  :                 if (here.val < 16) {

  00c4d	8b d0		 mov	 edx, eax
  00c4f	c1 ea 10	 shr	 edx, 16			; 00000010H
  00c52	66 83 fa 10	 cmp	 dx, 16			; 00000010H
  00c56	73 21		 jae	 SHORT $LN929@inflate

; 967  :                     DROPBITS(here.bits);

  00c58	c1 e8 08	 shr	 eax, 8
  00c5b	0f b6 c8	 movzx	 ecx, al
  00c5e	d3 6d fc	 shr	 DWORD PTR _hold$1$[ebp], cl
  00c61	2b f1		 sub	 esi, ecx

; 968  :                     state->lens[state->have++] = here.val;

  00c63	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00c66	8b 45 d8	 mov	 eax, DWORD PTR tv2728[ebp]
  00c69	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00c6c	66 89 54 41 74	 mov	 WORD PTR [ecx+eax*2+116], dx
  00c71	ff 41 6c	 inc	 DWORD PTR [ecx+108]

; 969  :                 }

  00c74	e9 5d 01 00 00	 jmp	 $LN610@inflate
$LN929@inflate:

; 970  :                 else {
; 971  :                     if (here.val == 16) {

  00c79	75 70		 jne	 SHORT $LN435@inflate

; 972  :                         NEEDBITS(here.bits + 2);

  00c7b	8b c8		 mov	 ecx, eax
  00c7d	c1 e9 08	 shr	 ecx, 8
  00c80	0f b6 c9	 movzx	 ecx, cl
  00c83	83 c1 02	 add	 ecx, 2
  00c86	89 4d c8	 mov	 DWORD PTR $T1[ebp], ecx
  00c89	3b f1		 cmp	 esi, ecx
  00c8b	73 25		 jae	 SHORT $LN196@inflate
  00c8d	0f 1f 00	 npad	 3
$LL199@inflate:
  00c90	85 db		 test	 ebx, ebx
  00c92	0f 84 26 f9 ff
	ff		 je	 $LN887@inflate
  00c98	0f b6 17	 movzx	 edx, BYTE PTR [edi]
  00c9b	8b ce		 mov	 ecx, esi
  00c9d	d3 e2		 shl	 edx, cl
  00c9f	4b		 dec	 ebx
  00ca0	01 55 fc	 add	 DWORD PTR _hold$1$[ebp], edx
  00ca3	47		 inc	 edi
  00ca4	83 c6 08	 add	 esi, 8
  00ca7	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00caa	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00cad	3b 75 c8	 cmp	 esi, DWORD PTR $T1[ebp]
  00cb0	72 de		 jb	 SHORT $LL199@inflate
$LN196@inflate:

; 973  :                         DROPBITS(here.bits);

  00cb2	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00cb5	0f b6 cc	 movzx	 ecx, ah

; 974  :                         if (state->have == 0) {

  00cb8	8b 45 d8	 mov	 eax, DWORD PTR tv2728[ebp]
  00cbb	2b f1		 sub	 esi, ecx
  00cbd	d3 ea		 shr	 edx, cl

; 976  :                             state->mode = BAD;
; 977  :                             break;
; 978  :                         }
; 979  :                         len = state->lens[state->have - 1];

  00cbf	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00cc2	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00cc5	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00cc8	85 c0		 test	 eax, eax
  00cca	0f 84 40 01 00
	00		 je	 $LN567@inflate
  00cd0	0f b7 44 41 72	 movzx	 eax, WORD PTR [ecx+eax*2+114]

; 980  :                         copy = 3 + BITS(2);

  00cd5	8b ca		 mov	 ecx, edx
  00cd7	83 e1 03	 and	 ecx, 3

; 981  :                         DROPBITS(2);

  00cda	c1 ea 02	 shr	 edx, 2
  00cdd	83 c1 03	 add	 ecx, 3
  00ce0	89 45 c8	 mov	 DWORD PTR _len$5$[ebp], eax
  00ce3	83 ee 02	 sub	 esi, 2

; 982  :                     }

  00ce6	e9 ac 00 00 00	 jmp	 $LN930@inflate
$LN435@inflate:

; 983  :                     else if (here.val == 17) {

  00ceb	66 83 7d ca 11	 cmp	 WORD PTR _here$[ebp+2], 17 ; 00000011H
  00cf0	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]

; 984  :                         NEEDBITS(here.bits + 3);

  00cf3	0f b6 cc	 movzx	 ecx, ah
  00cf6	75 4a		 jne	 SHORT $LN226@inflate
  00cf8	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00cfb	89 4d ec	 mov	 DWORD PTR tv2707[ebp], ecx
  00cfe	3b f0		 cmp	 esi, eax
  00d00	73 29		 jae	 SHORT $LN210@inflate
$LL213@inflate:
  00d02	85 db		 test	 ebx, ebx
  00d04	0f 84 b4 f8 ff
	ff		 je	 $LN887@inflate
  00d0a	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00d0d	8b ce		 mov	 ecx, esi
  00d0f	d3 e0		 shl	 eax, cl
  00d11	4b		 dec	 ebx
  00d12	8b 4d ec	 mov	 ecx, DWORD PTR tv2707[ebp]
  00d15	03 d0		 add	 edx, eax
  00d17	47		 inc	 edi
  00d18	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d1b	83 c6 08	 add	 esi, 8
  00d1e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d21	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d24	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00d27	3b f0		 cmp	 esi, eax
  00d29	72 d7		 jb	 SHORT $LL213@inflate
$LN210@inflate:

; 985  :                         DROPBITS(here.bits);

  00d2b	d3 ea		 shr	 edx, cl

; 986  :                         len = 0;
; 987  :                         copy = 3 + BITS(3);
; 988  :                         DROPBITS(3);

  00d2d	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00d32	8b ca		 mov	 ecx, edx
  00d34	c1 ea 03	 shr	 edx, 3
  00d37	83 e1 07	 and	 ecx, 7
  00d3a	83 c1 03	 add	 ecx, 3
  00d3d	2b 45 ec	 sub	 eax, DWORD PTR tv2707[ebp]

; 989  :                     }

  00d40	eb 4c		 jmp	 SHORT $LN931@inflate
$LN226@inflate:

; 990  :                     else {
; 991  :                         NEEDBITS(here.bits + 7);

  00d42	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d45	89 4d ec	 mov	 DWORD PTR tv2705[ebp], ecx
  00d48	3b f0		 cmp	 esi, eax
  00d4a	73 2d		 jae	 SHORT $LN224@inflate
  00d4c	0f 1f 40 00	 npad	 4
$LL227@inflate:
  00d50	85 db		 test	 ebx, ebx
  00d52	0f 84 66 f8 ff
	ff		 je	 $LN887@inflate
  00d58	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00d5b	8b ce		 mov	 ecx, esi
  00d5d	d3 e0		 shl	 eax, cl
  00d5f	4b		 dec	 ebx
  00d60	8b 4d ec	 mov	 ecx, DWORD PTR tv2705[ebp]
  00d63	03 d0		 add	 edx, eax
  00d65	47		 inc	 edi
  00d66	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00d69	83 c6 08	 add	 esi, 8
  00d6c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00d6f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00d72	8d 41 07	 lea	 eax, DWORD PTR [ecx+7]
  00d75	3b f0		 cmp	 esi, eax
  00d77	72 d7		 jb	 SHORT $LL227@inflate
$LN224@inflate:

; 992  :                         DROPBITS(here.bits);

  00d79	d3 ea		 shr	 edx, cl

; 993  :                         len = 0;
; 994  :                         copy = 11 + BITS(7);
; 995  :                         DROPBITS(7);

  00d7b	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d80	8b ca		 mov	 ecx, edx
  00d82	c1 ea 07	 shr	 edx, 7
  00d85	83 e1 7f	 and	 ecx, 127		; 0000007fH
  00d88	83 c1 0b	 add	 ecx, 11			; 0000000bH
  00d8b	2b 45 ec	 sub	 eax, DWORD PTR tv2705[ebp]
$LN931@inflate:
  00d8e	03 f0		 add	 esi, eax
  00d90	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _len$5$[ebp], 0
$LN930@inflate:

; 996  :                     }
; 997  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d97	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00d9a	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  00d9d	89 4d cc	 mov	 DWORD PTR _copy$8$[ebp], ecx
  00da0	03 4d d8	 add	 ecx, DWORD PTR tv2728[ebp]
  00da3	8b 40 68	 mov	 eax, DWORD PTR [eax+104]
  00da6	03 47 64	 add	 eax, DWORD PTR [edi+100]
  00da9	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00dac	3b c8		 cmp	 ecx, eax
  00dae	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00db1	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00db4	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00db7	77 57		 ja	 SHORT $LN567@inflate

; 998  :                         strm->msg = (char *)"invalid bit length repeat";
; 999  :                         state->mode = BAD;
; 1000 :                         break;
; 1001 :                     }
; 1002 :                     while (copy--)

  00db9	8b 55 cc	 mov	 edx, DWORD PTR _copy$8$[ebp]
  00dbc	85 d2		 test	 edx, edx
  00dbe	74 16		 je	 SHORT $LN610@inflate
  00dc0	8b 5d c8	 mov	 ebx, DWORD PTR _len$5$[ebp]
$LL238@inflate:

; 1003 :                         state->lens[state->have++] = (unsigned short)len;

  00dc3	8b 41 6c	 mov	 eax, DWORD PTR [ecx+108]
  00dc6	66 89 5c 41 74	 mov	 WORD PTR [ecx+eax*2+116], bx
  00dcb	ff 41 6c	 inc	 DWORD PTR [ecx+108]
  00dce	83 ea 01	 sub	 edx, 1
  00dd1	75 f0		 jne	 SHORT $LL238@inflate
  00dd3	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN610@inflate:

; 959  :         case CODELENS:
; 960  :             while (state->have < state->nlen + state->ndist) {

  00dd6	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00dd9	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00ddc	03 41 64	 add	 eax, DWORD PTR [ecx+100]
  00ddf	89 55 d8	 mov	 DWORD PTR tv2728[ebp], edx
  00de2	3b d0		 cmp	 edx, eax
  00de4	0f 82 f6 fd ff
	ff		 jb	 $LL185@inflate
$LN186@inflate:

; 1004 :                 }
; 1005 :             }
; 1006 : 
; 1007 :             /* handle error breaks in while */
; 1008 :             if (state->mode == BAD) break;

  00dea	81 79 04 51 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00df1	0f 84 92 fd ff
	ff		 je	 $LN888@inflate

; 1009 : 
; 1010 :             /* check for end-of-block code (better have one) */
; 1011 :             if (state->lens[256] == 0) {

  00df7	66 83 b9 74 02
	00 00 00	 cmp	 WORD PTR [ecx+628], 0
  00dff	75 25		 jne	 SHORT $LN445@inflate

; 1012 :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00e01	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e04	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@

; 1014 :                 break;

  00e0b	e9 72 fd ff ff	 jmp	 $LN932@inflate
$LN567@inflate:

; 975  :                             strm->msg = (char *)"invalid bit length repeat";

  00e10	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e13	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00e1a	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  00e21	e9 66 fd ff ff	 jmp	 $LN8@inflate
$LN445@inflate:

; 1015 :             }
; 1016 : 
; 1017 :             /* build code tables -- note: do not change the lenbits or distbits
; 1018 :                values here (9 and 6) without reading the comments in inftrees.h
; 1019 :                concerning the ENOUGH constants, which depend on those values */
; 1020 :             state->next = state->codes;

  00e26	8d 51 70	 lea	 edx, DWORD PTR [ecx+112]

; 1021 :             state->lencode = (const code FAR *)(state->next);
; 1022 :             state->lenbits = 9;

  00e29	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9
  00e30	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  00e36	89 55 c8	 mov	 DWORD PTR tv2721[ebp], edx
  00e39	89 02		 mov	 DWORD PTR [edx], eax
  00e3b	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 1023 :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),

  00e3e	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e44	50		 push	 eax
  00e45	8d 41 58	 lea	 eax, DWORD PTR [ecx+88]
  00e48	50		 push	 eax
  00e49	52		 push	 edx
  00e4a	ff 71 64	 push	 DWORD PTR [ecx+100]
  00e4d	8d 51 74	 lea	 edx, DWORD PTR [ecx+116]
  00e50	b9 01 00 00 00	 mov	 ecx, 1
  00e55	e8 00 00 00 00	 call	 _inflate_table

; 1027 :                 state->mode = BAD;

  00e5a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00e5d	83 c4 10	 add	 esp, 16			; 00000010H
  00e60	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00e63	85 c0		 test	 eax, eax
  00e65	74 0f		 je	 SHORT $LN446@inflate

; 1024 :                                 &(state->lenbits), state->work);
; 1025 :             if (ret) {
; 1026 :                 strm->msg = (char *)"invalid literal/lengths set";

  00e67	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e6a	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 1028 :                 break;

  00e71	e9 0c fd ff ff	 jmp	 $LN932@inflate
$LN446@inflate:

; 1029 :             }
; 1030 :             state->distcode = (const code FAR *)(state->next);

  00e76	8b 55 c8	 mov	 edx, DWORD PTR tv2721[ebp]

; 1031 :             state->distbits = 6;

  00e79	c7 41 5c 06 00
	00 00		 mov	 DWORD PTR [ecx+92], 6
  00e80	8b 02		 mov	 eax, DWORD PTR [edx]
  00e82	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 1032 :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,

  00e85	8d 81 f4 02 00
	00		 lea	 eax, DWORD PTR [ecx+756]
  00e8b	50		 push	 eax
  00e8c	8d 41 5c	 lea	 eax, DWORD PTR [ecx+92]
  00e8f	50		 push	 eax
  00e90	8b 41 64	 mov	 eax, DWORD PTR [ecx+100]
  00e93	52		 push	 edx
  00e94	ff 71 68	 push	 DWORD PTR [ecx+104]
  00e97	83 c1 74	 add	 ecx, 116		; 00000074H
  00e9a	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00e9d	b9 02 00 00 00	 mov	 ecx, 2
  00ea2	e8 00 00 00 00	 call	 _inflate_table

; 1036 :                 state->mode = BAD;

  00ea7	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00eaa	83 c4 10	 add	 esp, 16			; 00000010H
  00ead	89 45 d4	 mov	 DWORD PTR _ret$1$[ebp], eax
  00eb0	85 c0		 test	 eax, eax
  00eb2	74 0f		 je	 SHORT $LN447@inflate

; 1033 :                             &(state->next), &(state->distbits), state->work);
; 1034 :             if (ret) {
; 1035 :                 strm->msg = (char *)"invalid distances set";

  00eb4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00eb7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 1037 :                 break;

  00ebe	e9 bf fc ff ff	 jmp	 $LN932@inflate
$LN447@inflate:

; 1038 :             }
; 1039 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1040 :             state->mode = LEN_;
; 1041 :             if (flush == Z_TREES) goto inf_leave;

  00ec3	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  00ec6	c7 41 04 47 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16199 ; 00003f47H
  00ecd	83 fa 06	 cmp	 edx, 6
  00ed0	0f 84 32 07 00
	00		 je	 $LN863@inflate
  00ed6	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN448@inflate:

; 1042 :         case LEN_:
; 1043 :             state->mode = LEN;

  00ed9	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
$LN450@inflate:

; 1044 :         case LEN:
; 1045 :             if (have >= 6 && left >= 258) {

  00ee0	83 fb 06	 cmp	 ebx, 6
  00ee3	72 77		 jb	 SHORT $LN451@inflate
  00ee5	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$1$[ebp], 258 ; 00000102H
  00eec	72 6e		 jb	 SHORT $LN451@inflate

; 1046 :                 RESTORE();

  00eee	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ef1	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]

; 1047 :                 inflate_fast(strm, out);

  00ef4	ff 75 dc	 push	 DWORD PTR _out$1$[ebp]
  00ef7	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00efa	8b 7d e8	 mov	 edi, DWORD PTR _left$1$[ebp]
  00efd	89 78 10	 mov	 DWORD PTR [eax+16], edi
  00f00	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  00f03	89 38		 mov	 DWORD PTR [eax], edi
  00f05	89 58 04	 mov	 DWORD PTR [eax+4], ebx
  00f08	50		 push	 eax
  00f09	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  00f0c	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  00f0f	e8 00 00 00 00	 call	 _inflate_fast

; 1048 :                 LOAD();

  00f14	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00f17	83 c4 08	 add	 esp, 8
  00f1a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00f1d	8b 38		 mov	 edi, DWORD PTR [eax]
  00f1f	8b 58 04	 mov	 ebx, DWORD PTR [eax+4]
  00f22	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  00f25	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00f28	89 4d e8	 mov	 DWORD PTR _left$1$[ebp], ecx
  00f2b	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  00f2e	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00f31	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx

; 1049 :                 if (state->mode == TYPE)

  00f34	81 79 04 3f 3f
	00 00		 cmp	 DWORD PTR [ecx+4], 16191 ; 00003f3fH
  00f3b	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  00f3e	8b 71 40	 mov	 esi, DWORD PTR [ecx+64]
  00f41	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00f44	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  00f47	0f 85 3f fc ff
	ff		 jne	 $LN8@inflate

; 1050 :                     state->back = -1;

  00f4d	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 1051 :                 break;

  00f57	e9 30 fc ff ff	 jmp	 $LN8@inflate
$LN451@inflate:

; 1052 :             }
; 1053 :             state->back = 0;
; 1054 :             for (;;) {
; 1055 :                 here = state->lencode[BITS(state->lenbits)];

  00f5c	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  00f5f	c7 81 c8 1b 00
	00 00 00 00 00	 mov	 DWORD PTR [ecx+7112], 0
  00f69	8b 4d d0	 mov	 ecx, DWORD PTR tv2812[ebp]
  00f6c	89 45 cc	 mov	 DWORD PTR tv2719[ebp], eax
  00f6f	b8 01 00 00 00	 mov	 eax, 1
  00f74	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00f76	d3 e0		 shl	 eax, cl
  00f78	8b 4d cc	 mov	 ecx, DWORD PTR tv2719[ebp]
  00f7b	48		 dec	 eax
  00f7c	23 c2		 and	 eax, edx
  00f7e	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1056 :                 if ((unsigned)(here.bits) <= bits) break;

  00f81	8b c8		 mov	 ecx, eax
  00f83	c1 e9 08	 shr	 ecx, 8
  00f86	0f b6 c9	 movzx	 ecx, cl
  00f89	3b ce		 cmp	 ecx, esi
  00f8b	76 4a		 jbe	 SHORT $LN569@inflate
  00f8d	0f 1f 00	 npad	 3
$LL246@inflate:

; 1057 :                 PULLBYTE();

  00f90	85 db		 test	 ebx, ebx
  00f92	0f 84 26 f6 ff
	ff		 je	 $LN887@inflate
  00f98	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  00f9b	8b ce		 mov	 ecx, esi
  00f9d	d3 e0		 shl	 eax, cl
  00f9f	4b		 dec	 ebx
  00fa0	03 d0		 add	 edx, eax
  00fa2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  00fa5	8b 45 d0	 mov	 eax, DWORD PTR tv2812[ebp]
  00fa8	47		 inc	 edi
  00fa9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  00fac	83 c6 08	 add	 esi, 8
  00faf	ba 01 00 00 00	 mov	 edx, 1
  00fb4	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  00fb7	8b 08		 mov	 ecx, DWORD PTR [eax]
  00fb9	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  00fbc	d3 e2		 shl	 edx, cl
  00fbe	4a		 dec	 edx
  00fbf	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  00fc2	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  00fc5	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  00fc8	8b c8		 mov	 ecx, eax
  00fca	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  00fcd	c1 e9 08	 shr	 ecx, 8
  00fd0	0f b6 c9	 movzx	 ecx, cl
  00fd3	3b ce		 cmp	 ecx, esi
  00fd5	77 b9		 ja	 SHORT $LL246@inflate
$LN569@inflate:

; 1058 :             }
; 1059 :             if (here.op && (here.op & 0xf0) == 0) {

  00fd7	84 c0		 test	 al, al
  00fd9	0f 84 be 00 00
	00		 je	 $LN263@inflate
  00fdf	a8 f0		 test	 al, 240			; 000000f0H
  00fe1	0f 85 b6 00 00
	00		 jne	 $LN263@inflate

; 1060 :                 last = here;
; 1061 :                 for (;;) {
; 1062 :                     here = state->lencode[last.val +

  00fe7	8b c8		 mov	 ecx, eax
  00fe9	bb 01 00 00 00	 mov	 ebx, 1
  00fee	c1 e9 08	 shr	 ecx, 8
  00ff1	8b d0		 mov	 edx, eax
  00ff3	0f b6 f9	 movzx	 edi, cl
  00ff6	89 4d d8	 mov	 DWORD PTR tv2718[ebp], ecx
  00ff9	0f b6 c8	 movzx	 ecx, al
  00ffc	03 cf		 add	 ecx, edi
  00ffe	c1 e8 10	 shr	 eax, 16			; 00000010H
  01001	d3 e3		 shl	 ebx, cl
  01003	8b cf		 mov	 ecx, edi
  01005	4b		 dec	 ebx
  01006	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01009	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  0100c	d3 eb		 shr	 ebx, cl
  0100e	8b 4d cc	 mov	 ecx, DWORD PTR tv2719[ebp]
  01011	03 d8		 add	 ebx, eax
  01013	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1063 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1064 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  01016	8b c8		 mov	 ecx, eax
  01018	c1 e9 08	 shr	 ecx, 8
  0101b	0f b6 f9	 movzx	 edi, cl
  0101e	8b 4d d8	 mov	 ecx, DWORD PTR tv2718[ebp]
  01021	0f b6 c9	 movzx	 ecx, cl
  01024	03 f9		 add	 edi, ecx
  01026	3b fe		 cmp	 edi, esi
  01028	76 5d		 jbe	 SHORT $LN260@inflate
  0102a	66 0f 1f 44 00
	00		 npad	 6
$LL252@inflate:

; 1065 :                     PULLBYTE();

  01030	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01033	85 c0		 test	 eax, eax
  01035	0f 84 86 f5 ff
	ff		 je	 $LN897@inflate
  0103b	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  0103e	48		 dec	 eax
  0103f	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01042	8b ce		 mov	 ecx, esi
  01044	bf 01 00 00 00	 mov	 edi, 1
  01049	83 c6 08	 add	 esi, 8
  0104c	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  0104f	43		 inc	 ebx
  01050	d3 e0		 shl	 eax, cl
  01052	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01055	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  01059	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0105c	0f b6 de	 movzx	 ebx, dh
  0105f	0f b6 ca	 movzx	 ecx, dl
  01062	03 cb		 add	 ecx, ebx
  01064	d3 e7		 shl	 edi, cl
  01066	8b cb		 mov	 ecx, ebx
  01068	4f		 dec	 edi
  01069	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0106c	d3 ef		 shr	 edi, cl
  0106e	03 f8		 add	 edi, eax
  01070	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01073	8b 40 50	 mov	 eax, DWORD PTR [eax+80]
  01076	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  01079	8b c8		 mov	 ecx, eax
  0107b	c1 e9 08	 shr	 ecx, 8
  0107e	0f b6 c9	 movzx	 ecx, cl
  01081	03 cb		 add	 ecx, ebx
  01083	3b ce		 cmp	 ecx, esi
  01085	77 a9		 ja	 SHORT $LL252@inflate
$LN260@inflate:

; 1066 :                 }
; 1067 :                 DROPBITS(last.bits);
; 1068 :                 state->back += last.bits;

  01087	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0108a	0f b6 ce	 movzx	 ecx, dh
  0108d	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  01090	d3 ea		 shr	 edx, cl
  01092	2b f1		 sub	 esi, ecx
  01094	89 8b c8 1b 00
	00		 mov	 DWORD PTR [ebx+7112], ecx
  0109a	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
$LN263@inflate:

; 1069 :             }
; 1070 :             DROPBITS(here.bits);
; 1071 :             state->back += here.bits;

  0109d	8b 7d f8	 mov	 edi, DWORD PTR _state$1$[ebp]
  010a0	8b c8		 mov	 ecx, eax
  010a2	c1 e9 08	 shr	 ecx, 8
  010a5	0f b6 c9	 movzx	 ecx, cl
  010a8	d3 ea		 shr	 edx, cl
  010aa	2b f1		 sub	 esi, ecx
  010ac	01 8f c8 1b 00
	00		 add	 DWORD PTR [edi+7112], ecx

; 1072 :             state->length = (unsigned)here.val;

  010b2	8b c8		 mov	 ecx, eax
  010b4	c1 e9 10	 shr	 ecx, 16			; 00000010H
  010b7	89 4f 44	 mov	 DWORD PTR [edi+68], ecx

; 1073 :             if ((int)(here.op) == 0) {

  010ba	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]

; 1074 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1075 :                         "inflate:         literal '%c'\n" :
; 1076 :                         "inflate:         literal 0x%02x\n", here.val));
; 1077 :                 state->mode = LIT;

  010bd	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  010c0	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  010c3	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  010c6	84 c0		 test	 al, al
  010c8	75 0c		 jne	 SHORT $LN458@inflate
  010ca	c7 41 04 4d 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16205 ; 00003f4dH

; 1078 :                 break;

  010d1	e9 b6 fa ff ff	 jmp	 $LN8@inflate
$LN458@inflate:

; 1079 :             }
; 1080 :             if (here.op & 32) {

  010d6	a8 20		 test	 al, 32			; 00000020H
  010d8	74 16		 je	 SHORT $LN459@inflate

; 1081 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1082 :                 state->back = -1;

  010da	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1
$LN419@inflate:

; 1083 :                 state->mode = TYPE;

  010e4	c7 41 04 3f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16191 ; 00003f3fH

; 1084 :                 break;

  010eb	e9 9c fa ff ff	 jmp	 $LN8@inflate
$LN459@inflate:

; 1085 :             }
; 1086 :             if (here.op & 64) {

  010f0	a8 40		 test	 al, 64			; 00000040H
  010f2	74 16		 je	 SHORT $LN460@inflate

; 1087 :                 strm->msg = (char *)"invalid literal/length code";

  010f4	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  010f7	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010fe	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  01105	e9 82 fa ff ff	 jmp	 $LN8@inflate
$LN460@inflate:

; 1088 :                 state->mode = BAD;
; 1089 :                 break;
; 1090 :             }
; 1091 :             state->extra = (unsigned)(here.op) & 15;

  0110a	0f b6 c0	 movzx	 eax, al
  0110d	83 e0 0f	 and	 eax, 15			; 0000000fH

; 1092 :             state->mode = LENEXT;

  01110	c7 41 04 49 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16201 ; 00003f49H
  01117	89 41 4c	 mov	 DWORD PTR [ecx+76], eax
$LN461@inflate:

; 1093 :         case LENEXT:
; 1094 :             if (state->extra) {

  0111a	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0111d	89 45 c8	 mov	 DWORD PTR tv2694[ebp], eax
  01120	85 c0		 test	 eax, eax
  01122	74 50		 je	 SHORT $LN462@inflate

; 1095 :                 NEEDBITS(state->extra);

  01124	3b f0		 cmp	 esi, eax
  01126	73 24		 jae	 SHORT $LN264@inflate
$LL267@inflate:
  01128	85 db		 test	 ebx, ebx
  0112a	0f 84 8e f4 ff
	ff		 je	 $LN887@inflate
  01130	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01133	8b ce		 mov	 ecx, esi
  01135	d3 e0		 shl	 eax, cl
  01137	4b		 dec	 ebx
  01138	03 d0		 add	 edx, eax
  0113a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0113d	47		 inc	 edi
  0113e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01141	83 c6 08	 add	 esi, 8
  01144	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01147	3b 75 c8	 cmp	 esi, DWORD PTR tv2694[ebp]
  0114a	72 dc		 jb	 SHORT $LL267@inflate
$LN264@inflate:

; 1096 :                 state->length += BITS(state->extra);

  0114c	8b 4d c8	 mov	 ecx, DWORD PTR tv2694[ebp]
  0114f	b8 01 00 00 00	 mov	 eax, 1
  01154	d3 e0		 shl	 eax, cl
  01156	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01159	48		 dec	 eax
  0115a	23 c2		 and	 eax, edx
  0115c	01 41 44	 add	 DWORD PTR [ecx+68], eax

; 1097 :                 DROPBITS(state->extra);

  0115f	8b 45 c8	 mov	 eax, DWORD PTR tv2694[ebp]
  01162	8b c8		 mov	 ecx, eax
  01164	d3 ea		 shr	 edx, cl
  01166	2b f0		 sub	 esi, eax

; 1098 :                 state->back += state->extra;

  01168	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0116b	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0116e	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN462@inflate:

; 1099 :             }
; 1100 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1101 :             state->was = state->length;

  01174	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  01177	89 81 cc 1b 00
	00		 mov	 DWORD PTR [ecx+7116], eax

; 1102 :             state->mode = DIST;

  0117d	c7 41 04 4a 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16202 ; 00003f4aH
$LN464@inflate:

; 1103 :         case DIST:
; 1104 :             for (;;) {
; 1105 :                 here = state->distcode[BITS(state->distbits)];

  01184	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  01187	8b 4d c0	 mov	 ecx, DWORD PTR tv2809[ebp]
  0118a	89 45 cc	 mov	 DWORD PTR tv2692[ebp], eax
  0118d	b8 01 00 00 00	 mov	 eax, 1
  01192	8b 09		 mov	 ecx, DWORD PTR [ecx]
  01194	d3 e0		 shl	 eax, cl
  01196	8b 4d cc	 mov	 ecx, DWORD PTR tv2692[ebp]
  01199	48		 dec	 eax
  0119a	23 c2		 and	 eax, edx
  0119c	8b 04 81	 mov	 eax, DWORD PTR [ecx+eax*4]

; 1106 :                 if ((unsigned)(here.bits) <= bits) break;

  0119f	8b c8		 mov	 ecx, eax
  011a1	c1 e9 08	 shr	 ecx, 8
  011a4	0f b6 c9	 movzx	 ecx, cl
  011a7	3b ce		 cmp	 ecx, esi
  011a9	76 4c		 jbe	 SHORT $LN574@inflate
  011ab	0f 1f 44 00 00	 npad	 5
$LL275@inflate:

; 1107 :                 PULLBYTE();

  011b0	85 db		 test	 ebx, ebx
  011b2	0f 84 06 f4 ff
	ff		 je	 $LN887@inflate
  011b8	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  011bb	8b ce		 mov	 ecx, esi
  011bd	d3 e0		 shl	 eax, cl
  011bf	4b		 dec	 ebx
  011c0	03 d0		 add	 edx, eax
  011c2	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  011c5	8b 45 c0	 mov	 eax, DWORD PTR tv2809[ebp]
  011c8	47		 inc	 edi
  011c9	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  011cc	83 c6 08	 add	 esi, 8
  011cf	ba 01 00 00 00	 mov	 edx, 1
  011d4	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  011d7	8b 08		 mov	 ecx, DWORD PTR [eax]
  011d9	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  011dc	d3 e2		 shl	 edx, cl
  011de	4a		 dec	 edx
  011df	23 55 fc	 and	 edx, DWORD PTR _hold$1$[ebp]
  011e2	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  011e5	8b 04 90	 mov	 eax, DWORD PTR [eax+edx*4]
  011e8	8b c8		 mov	 ecx, eax
  011ea	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  011ed	c1 e9 08	 shr	 ecx, 8
  011f0	0f b6 c9	 movzx	 ecx, cl
  011f3	3b ce		 cmp	 ecx, esi
  011f5	77 b9		 ja	 SHORT $LL275@inflate
$LN574@inflate:

; 1108 :             }
; 1109 :             if ((here.op & 0xf0) == 0) {

  011f7	a8 f0		 test	 al, 240			; 000000f0H
  011f9	0f 85 af 00 00
	00		 jne	 $LN892@inflate

; 1110 :                 last = here;
; 1111 :                 for (;;) {
; 1112 :                     here = state->distcode[last.val +

  011ff	8b c8		 mov	 ecx, eax
  01201	bb 01 00 00 00	 mov	 ebx, 1
  01206	c1 e9 08	 shr	 ecx, 8
  01209	8b d0		 mov	 edx, eax
  0120b	0f b6 f9	 movzx	 edi, cl
  0120e	89 4d d8	 mov	 DWORD PTR tv2717[ebp], ecx
  01211	0f b6 c8	 movzx	 ecx, al
  01214	03 cf		 add	 ecx, edi
  01216	c1 e8 10	 shr	 eax, 16			; 00000010H
  01219	d3 e3		 shl	 ebx, cl
  0121b	8b cf		 mov	 ecx, edi
  0121d	4b		 dec	 ebx
  0121e	89 55 c8	 mov	 DWORD PTR _last$[ebp], edx
  01221	23 5d fc	 and	 ebx, DWORD PTR _hold$1$[ebp]
  01224	d3 eb		 shr	 ebx, cl
  01226	8b 4d cc	 mov	 ecx, DWORD PTR tv2692[ebp]
  01229	03 d8		 add	 ebx, eax
  0122b	8b 04 99	 mov	 eax, DWORD PTR [ecx+ebx*4]

; 1113 :                             (BITS(last.bits + last.op) >> last.bits)];
; 1114 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  0122e	8b c8		 mov	 ecx, eax
  01230	c1 e9 08	 shr	 ecx, 8
  01233	0f b6 f9	 movzx	 edi, cl
  01236	8b 4d d8	 mov	 ecx, DWORD PTR tv2717[ebp]
  01239	0f b6 c9	 movzx	 ecx, cl
  0123c	03 f9		 add	 edi, ecx
  0123e	3b fe		 cmp	 edi, esi
  01240	76 57		 jbe	 SHORT $LN289@inflate
$LL281@inflate:

; 1115 :                     PULLBYTE();

  01242	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  01245	85 c0		 test	 eax, eax
  01247	0f 84 74 f3 ff
	ff		 je	 $LN897@inflate
  0124d	8b 5d f0	 mov	 ebx, DWORD PTR _next$1$[ebp]
  01250	48		 dec	 eax
  01251	89 45 f4	 mov	 DWORD PTR _have$1$[ebp], eax
  01254	8b ce		 mov	 ecx, esi
  01256	bf 01 00 00 00	 mov	 edi, 1
  0125b	83 c6 08	 add	 esi, 8
  0125e	0f b6 03	 movzx	 eax, BYTE PTR [ebx]
  01261	43		 inc	 ebx
  01262	d3 e0		 shl	 eax, cl
  01264	01 45 fc	 add	 DWORD PTR _hold$1$[ebp], eax
  01267	0f b7 45 ca	 movzx	 eax, WORD PTR _last$[ebp+2]
  0126b	89 5d f0	 mov	 DWORD PTR _next$1$[ebp], ebx
  0126e	0f b6 de	 movzx	 ebx, dh
  01271	0f b6 ca	 movzx	 ecx, dl
  01274	03 cb		 add	 ecx, ebx
  01276	d3 e7		 shl	 edi, cl
  01278	8b cb		 mov	 ecx, ebx
  0127a	4f		 dec	 edi
  0127b	23 7d fc	 and	 edi, DWORD PTR _hold$1$[ebp]
  0127e	d3 ef		 shr	 edi, cl
  01280	03 f8		 add	 edi, eax
  01282	8b 45 f8	 mov	 eax, DWORD PTR _state$1$[ebp]
  01285	8b 40 54	 mov	 eax, DWORD PTR [eax+84]
  01288	8b 04 b8	 mov	 eax, DWORD PTR [eax+edi*4]
  0128b	8b c8		 mov	 ecx, eax
  0128d	c1 e9 08	 shr	 ecx, 8
  01290	0f b6 c9	 movzx	 ecx, cl
  01293	03 cb		 add	 ecx, ebx
  01295	3b ce		 cmp	 ecx, esi
  01297	77 a9		 ja	 SHORT $LL281@inflate
$LN289@inflate:

; 1116 :                 }
; 1117 :                 DROPBITS(last.bits);
; 1118 :                 state->back += last.bits;

  01299	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
  0129c	0f b6 ce	 movzx	 ecx, dh
  0129f	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
  012a2	2b f1		 sub	 esi, ecx
  012a4	d3 ea		 shr	 edx, cl
  012a6	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012ac	eb 03		 jmp	 SHORT $LN292@inflate
$LN892@inflate:
  012ae	8b 5d f8	 mov	 ebx, DWORD PTR _state$1$[ebp]
$LN292@inflate:

; 1125 :                 break;

  012b1	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  012b4	8b c8		 mov	 ecx, eax
  012b6	c1 e9 08	 shr	 ecx, 8
  012b9	0f b6 c9	 movzx	 ecx, cl
  012bc	01 8b c8 1b 00
	00		 add	 DWORD PTR [ebx+7112], ecx
  012c2	2b f1		 sub	 esi, ecx
  012c4	d3 ea		 shr	 edx, cl
  012c6	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  012c9	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  012cc	a8 40		 test	 al, 64			; 00000040H
  012ce	74 1c		 je	 SHORT $LN470@inflate

; 1119 :             }
; 1120 :             DROPBITS(here.bits);
; 1121 :             state->back += here.bits;
; 1122 :             if (here.op & 64) {
; 1123 :                 strm->msg = (char *)"invalid distance code";
; 1124 :                 state->mode = BAD;

  012d0	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  012d3	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]

; 1125 :                 break;

  012d6	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  012d9	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  012e0	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  012e7	e9 a0 f8 ff ff	 jmp	 $LN8@inflate
$LN470@inflate:

; 1126 :             }
; 1127 :             state->offset = (unsigned)here.val;

  012ec	8b c8		 mov	 ecx, eax

; 1128 :             state->extra = (unsigned)(here.op) & 15;

  012ee	0f b6 c0	 movzx	 eax, al
  012f1	c1 e9 10	 shr	 ecx, 16			; 00000010H
  012f4	83 e0 0f	 and	 eax, 15			; 0000000fH
  012f7	89 4b 48	 mov	 DWORD PTR [ebx+72], ecx
  012fa	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  012fd	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  01300	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1129 :             state->mode = DISTEXT;

  01303	c7 41 04 4b 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16203 ; 00003f4bH
$LN471@inflate:

; 1130 :         case DISTEXT:
; 1131 :             if (state->extra) {

  0130a	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  0130d	89 45 c8	 mov	 DWORD PTR tv2693[ebp], eax
  01310	85 c0		 test	 eax, eax
  01312	74 53		 je	 SHORT $LN472@inflate

; 1132 :                 NEEDBITS(state->extra);

  01314	3b f0		 cmp	 esi, eax
  01316	73 24		 jae	 SHORT $LN293@inflate
$LL296@inflate:
  01318	85 db		 test	 ebx, ebx
  0131a	0f 84 9e f2 ff
	ff		 je	 $LN887@inflate
  01320	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  01323	8b ce		 mov	 ecx, esi
  01325	d3 e0		 shl	 eax, cl
  01327	4b		 dec	 ebx
  01328	03 d0		 add	 edx, eax
  0132a	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0132d	47		 inc	 edi
  0132e	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01331	83 c6 08	 add	 esi, 8
  01334	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01337	3b 75 c8	 cmp	 esi, DWORD PTR tv2693[ebp]
  0133a	72 dc		 jb	 SHORT $LL296@inflate
$LN293@inflate:

; 1133 :                 state->offset += BITS(state->extra);

  0133c	8b 4d c8	 mov	 ecx, DWORD PTR tv2693[ebp]
  0133f	b8 01 00 00 00	 mov	 eax, 1
  01344	d3 e0		 shl	 eax, cl
  01346	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01349	48		 dec	 eax
  0134a	23 c2		 and	 eax, edx
  0134c	01 41 48	 add	 DWORD PTR [ecx+72], eax

; 1134 :                 DROPBITS(state->extra);

  0134f	8b 45 c8	 mov	 eax, DWORD PTR tv2693[ebp]
  01352	8b c8		 mov	 ecx, eax
  01354	d3 ea		 shr	 edx, cl
  01356	2b f0		 sub	 esi, eax

; 1135 :                 state->back += state->extra;

  01358	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  0135b	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0135e	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01361	01 81 c8 1b 00
	00		 add	 DWORD PTR [ecx+7112], eax
$LN472@inflate:

; 1136 :             }
; 1137 : #ifdef INFLATE_STRICT
; 1138 :             if (state->offset > state->dmax) {
; 1139 :                 strm->msg = (char *)"invalid distance too far back";
; 1140 :                 state->mode = BAD;
; 1141 :                 break;
; 1142 :             }
; 1143 : #endif
; 1144 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1145 :             state->mode = MATCH;

  01367	c7 41 04 4c 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16204 ; 00003f4cH
$LN474@inflate:

; 1146 :         case MATCH:
; 1147 :             if (left == 0) goto inf_leave;

  0136e	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01372	0f 84 46 f2 ff
	ff		 je	 $LN887@inflate

; 1148 :             copy = out - left;

  01378	8b 45 dc	 mov	 eax, DWORD PTR _out$1$[ebp]
  0137b	2b 45 e8	 sub	 eax, DWORD PTR _left$1$[ebp]
  0137e	89 45 c8	 mov	 DWORD PTR _copy$9$[ebp], eax

; 1149 :             if (state->offset > copy) {         /* copy from window */

  01381	8b 41 48	 mov	 eax, DWORD PTR [ecx+72]
  01384	3b 45 c8	 cmp	 eax, DWORD PTR _copy$9$[ebp]
  01387	76 55		 jbe	 SHORT $LN476@inflate

; 1150 :                 copy = state->offset - copy;

  01389	2b 45 c8	 sub	 eax, DWORD PTR _copy$9$[ebp]

; 1151 :                 if (copy > state->whave) {

  0138c	3b 41 30	 cmp	 eax, DWORD PTR [ecx+48]
  0138f	76 1f		 jbe	 SHORT $LN479@inflate

; 1152 :                     if (state->sane) {

  01391	83 b9 c4 1b 00
	00 00		 cmp	 DWORD PTR [ecx+7108], 0
  01398	74 16		 je	 SHORT $LN479@inflate

; 1153 :                         strm->msg = (char *)"invalid distance too far back";

  0139a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0139d	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  013a4	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  013ab	e9 dc f7 ff ff	 jmp	 $LN8@inflate
$LN479@inflate:

; 1154 :                         state->mode = BAD;
; 1155 :                         break;
; 1156 :                     }
; 1157 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1158 :                     Trace((stderr, "inflate.c too far\n"));
; 1159 :                     copy -= state->whave;
; 1160 :                     if (copy > state->length) copy = state->length;
; 1161 :                     if (copy > left) copy = left;
; 1162 :                     left -= copy;
; 1163 :                     state->length -= copy;
; 1164 :                     do {
; 1165 :                         *put++ = 0;
; 1166 :                     } while (--copy);
; 1167 :                     if (state->length == 0) state->mode = LEN;
; 1168 :                     break;
; 1169 : #endif
; 1170 :                 }
; 1171 :                 if (copy > state->wnext) {

  013b0	3b 41 34	 cmp	 eax, DWORD PTR [ecx+52]
  013b3	76 10		 jbe	 SHORT $LN480@inflate

; 1172 :                     copy -= state->wnext;
; 1173 :                     from = state->window + (state->wsize - copy);

  013b5	8b 79 38	 mov	 edi, DWORD PTR [ecx+56]
  013b8	2b 41 34	 sub	 eax, DWORD PTR [ecx+52]
  013bb	03 79 2c	 add	 edi, DWORD PTR [ecx+44]
  013be	2b f8		 sub	 edi, eax
  013c0	89 7d d8	 mov	 DWORD PTR _from$1$[ebp], edi

; 1174 :                 }

  013c3	eb 0b		 jmp	 SHORT $LN481@inflate
$LN480@inflate:

; 1175 :                 else
; 1176 :                     from = state->window + (state->wnext - copy);

  013c5	8b 59 38	 mov	 ebx, DWORD PTR [ecx+56]
  013c8	2b d8		 sub	 ebx, eax
  013ca	03 59 34	 add	 ebx, DWORD PTR [ecx+52]
  013cd	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
$LN481@inflate:

; 1177 :                 if (copy > state->length) copy = state->length;

  013d0	8b 79 44	 mov	 edi, DWORD PTR [ecx+68]
  013d3	89 7d c8	 mov	 DWORD PTR tv2646[ebp], edi
  013d6	3b c7		 cmp	 eax, edi
  013d8	76 13		 jbe	 SHORT $LN477@inflate
  013da	8b c7		 mov	 eax, edi

; 1178 :             }

  013dc	eb 0f		 jmp	 SHORT $LN477@inflate
$LN476@inflate:

; 1179 :             else {                              /* copy from output */
; 1180 :                 from = put - state->offset;

  013de	8b 5d e0	 mov	 ebx, DWORD PTR _put$1$[ebp]
  013e1	89 5d d8	 mov	 DWORD PTR _from$1$[ebp], ebx
  013e4	29 45 d8	 sub	 DWORD PTR _from$1$[ebp], eax

; 1181 :                 copy = state->length;

  013e7	8b 41 44	 mov	 eax, DWORD PTR [ecx+68]
  013ea	89 45 c8	 mov	 DWORD PTR tv2646[ebp], eax
$LN477@inflate:

; 1182 :             }
; 1183 :             if (copy > left) copy = left;

  013ed	8b 5d e8	 mov	 ebx, DWORD PTR _left$1$[ebp]
  013f0	3b c3		 cmp	 eax, ebx
  013f2	0f 47 c3	 cmova	 eax, ebx

; 1184 :             left -= copy;

  013f5	2b d8		 sub	 ebx, eax
  013f7	89 45 cc	 mov	 DWORD PTR _copy$11$[ebp], eax
  013fa	89 5d e8	 mov	 DWORD PTR _left$1$[ebp], ebx
  013fd	8b f8		 mov	 edi, eax

; 1185 :             state->length -= copy;

  013ff	8b 5d c8	 mov	 ebx, DWORD PTR tv2646[ebp]
  01402	2b d8		 sub	 ebx, eax
  01404	89 59 44	 mov	 DWORD PTR [ecx+68], ebx

; 1188 :             } while (--copy);

  01407	8b 5d d8	 mov	 ebx, DWORD PTR _from$1$[ebp]
  0140a	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  0140d	2b d9		 sub	 ebx, ecx
  0140f	90		 npad	 1
$LL306@inflate:

; 1186 :             do {
; 1187 :                 *put++ = *from++;

  01410	8a 04 0b	 mov	 al, BYTE PTR [ebx+ecx]
  01413	88 01		 mov	 BYTE PTR [ecx], al
  01415	41		 inc	 ecx

; 1188 :             } while (--copy);

  01416	83 ef 01	 sub	 edi, 1
  01419	75 f5		 jne	 SHORT $LL306@inflate

; 1189 :             if (state->length == 0) state->mode = LEN;

  0141b	8b 5d f4	 mov	 ebx, DWORD PTR _have$1$[ebp]
  0141e	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01421	89 4d e0	 mov	 DWORD PTR _put$1$[ebp], ecx
  01424	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  01427	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  0142b	0f 85 5b f7 ff
	ff		 jne	 $LN8@inflate
  01431	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H

; 1190 :             break;

  01438	e9 4f f7 ff ff	 jmp	 $LN8@inflate
$LN485@inflate:

; 1191 :         case LIT:
; 1192 :             if (left == 0) goto inf_leave;

  0143d	83 7d e8 00	 cmp	 DWORD PTR _left$1$[ebp], 0
  01441	0f 84 77 f1 ff
	ff		 je	 $LN887@inflate

; 1193 :             *put++ = (unsigned char)(state->length);

  01447	8b 7d e0	 mov	 edi, DWORD PTR _put$1$[ebp]
  0144a	8a 41 44	 mov	 al, BYTE PTR [ecx+68]
  0144d	ff 45 e0	 inc	 DWORD PTR _put$1$[ebp]

; 1194 :             left--;

  01450	ff 4d e8	 dec	 DWORD PTR _left$1$[ebp]
  01453	88 07		 mov	 BYTE PTR [edi], al

; 1195 :             state->mode = LEN;
; 1196 :             break;

  01455	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  01458	c7 41 04 48 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16200 ; 00003f48H
  0145f	e9 28 f7 ff ff	 jmp	 $LN8@inflate
$LN487@inflate:

; 1197 :         case CHECK:
; 1198 :             if (state->wrap) {

  01464	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  01468	0f 84 e1 00 00
	00		 je	 $LN316@inflate

; 1199 :                 NEEDBITS(32);

  0146e	83 fe 20	 cmp	 esi, 32			; 00000020H
  01471	73 2a		 jae	 SHORT $LN307@inflate
$LL310@inflate:
  01473	85 db		 test	 ebx, ebx
  01475	0f 84 43 f1 ff
	ff		 je	 $LN887@inflate
  0147b	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0147e	8b ce		 mov	 ecx, esi
  01480	d3 e0		 shl	 eax, cl
  01482	83 c6 08	 add	 esi, 8
  01485	4b		 dec	 ebx
  01486	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01489	03 d0		 add	 edx, eax
  0148b	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0148e	47		 inc	 edi
  0148f	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  01492	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01495	83 fe 20	 cmp	 esi, 32			; 00000020H
  01498	72 d9		 jb	 SHORT $LL310@inflate
  0149a	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN307@inflate:

; 1200 :                 out -= left;

  0149d	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014a0	29 45 dc	 sub	 DWORD PTR _out$1$[ebp], eax

; 1201 :                 strm->total_out += out;

  014a3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014a6	8b 7d dc	 mov	 edi, DWORD PTR _out$1$[ebp]
  014a9	01 78 14	 add	 DWORD PTR [eax+20], edi

; 1202 :                 state->total += out;

  014ac	8b c7		 mov	 eax, edi
  014ae	01 41 20	 add	 DWORD PTR [ecx+32], eax

; 1203 :                 if ((state->wrap & 4) && out)

  014b1	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014b5	8b 7d f0	 mov	 edi, DWORD PTR _next$1$[ebp]
  014b8	74 30		 je	 SHORT $LN490@inflate
  014ba	85 c0		 test	 eax, eax
  014bc	74 2c		 je	 SHORT $LN490@inflate

; 1204 :                     strm->adler = state->check =

  014be	50		 push	 eax
  014bf	8b 45 e0	 mov	 eax, DWORD PTR _put$1$[ebp]
  014c2	2b 45 dc	 sub	 eax, DWORD PTR _out$1$[ebp]
  014c5	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014c9	50		 push	 eax
  014ca	ff 71 1c	 push	 DWORD PTR [ecx+28]
  014cd	74 07		 je	 SHORT $LN511@inflate
  014cf	e8 00 00 00 00	 call	 _crc32@12
  014d4	eb 05		 jmp	 SHORT $LN512@inflate
$LN511@inflate:
  014d6	e8 00 00 00 00	 call	 _adler32@12
$LN512@inflate:
  014db	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  014de	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014e1	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  014e4	89 42 30	 mov	 DWORD PTR [edx+48], eax
  014e7	8b 55 fc	 mov	 edx, DWORD PTR _hold$1$[ebp]
$LN490@inflate:

; 1205 :                         UPDATE(state->check, put - out, out);
; 1206 :                 out = left;
; 1207 :                 if ((state->wrap & 4) && (

  014ea	f6 41 0c 04	 test	 BYTE PTR [ecx+12], 4
  014ee	8b 45 e8	 mov	 eax, DWORD PTR _left$1$[ebp]
  014f1	89 45 dc	 mov	 DWORD PTR _out$1$[ebp], eax
  014f4	74 4f		 je	 SHORT $LN317@inflate
  014f6	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  014fa	8b c2		 mov	 eax, edx
  014fc	75 2c		 jne	 SHORT $LN514@inflate
  014fe	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01503	89 45 d8	 mov	 DWORD PTR tv2819[ebp], eax
  01506	8b c2		 mov	 eax, edx
  01508	c1 e0 10	 shl	 eax, 16			; 00000010H
  0150b	01 45 d8	 add	 DWORD PTR tv2819[ebp], eax
  0150e	8b c2		 mov	 eax, edx
  01510	c1 65 d8 08	 shl	 DWORD PTR tv2819[ebp], 8
  01514	c1 e8 08	 shr	 eax, 8
  01517	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0151c	01 45 d8	 add	 DWORD PTR tv2819[ebp], eax
  0151f	8b c2		 mov	 eax, edx
  01521	c1 e8 18	 shr	 eax, 24			; 00000018H
  01524	01 45 d8	 add	 DWORD PTR tv2819[ebp], eax
  01527	8b 45 d8	 mov	 eax, DWORD PTR tv2819[ebp]
$LN514@inflate:
  0152a	3b 41 1c	 cmp	 eax, DWORD PTR [ecx+28]
  0152d	74 16		 je	 SHORT $LN317@inflate

; 1208 : #ifdef GUNZIP
; 1209 :                      state->flags ? hold :
; 1210 : #endif
; 1211 :                      ZSWAP32(hold)) != state->check) {
; 1212 :                     strm->msg = (char *)"incorrect data check";

  0152f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01532	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  01539	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  01540	e9 47 f6 ff ff	 jmp	 $LN8@inflate
$LN317@inflate:

; 1213 :                     state->mode = BAD;
; 1214 :                     break;
; 1215 :                 }
; 1216 :                 INITBITS();

  01545	33 d2		 xor	 edx, edx
  01547	33 f6		 xor	 esi, esi
  01549	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0154c	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
$LN316@inflate:

; 1217 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1218 :             }
; 1219 : #ifdef GUNZIP
; 1220 :             state->mode = LENGTH;

  0154f	c7 41 04 4f 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16207 ; 00003f4fH
$LN492@inflate:

; 1221 :         case LENGTH:
; 1222 :             if (state->wrap && state->flags) {

  01556	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0155a	0f 84 89 00 00
	00		 je	 $LN327@inflate
  01560	83 79 14 00	 cmp	 DWORD PTR [ecx+20], 0
  01564	0f 84 7f 00 00
	00		 je	 $LN327@inflate

; 1223 :                 NEEDBITS(32);

  0156a	83 fe 20	 cmp	 esi, 32			; 00000020H
  0156d	73 2b		 jae	 SHORT $LN318@inflate
  0156f	90		 npad	 1
$LL321@inflate:
  01570	85 db		 test	 ebx, ebx
  01572	0f 84 46 f0 ff
	ff		 je	 $LN887@inflate
  01578	0f b6 07	 movzx	 eax, BYTE PTR [edi]
  0157b	8b ce		 mov	 ecx, esi
  0157d	d3 e0		 shl	 eax, cl
  0157f	83 c6 08	 add	 esi, 8
  01582	4b		 dec	 ebx
  01583	89 75 ec	 mov	 DWORD PTR _bits$1$[ebp], esi
  01586	03 d0		 add	 edx, eax
  01588	89 5d f4	 mov	 DWORD PTR _have$1$[ebp], ebx
  0158b	47		 inc	 edi
  0158c	89 55 fc	 mov	 DWORD PTR _hold$1$[ebp], edx
  0158f	89 7d f0	 mov	 DWORD PTR _next$1$[ebp], edi
  01592	83 fe 20	 cmp	 esi, 32			; 00000020H
  01595	72 d9		 jb	 SHORT $LL321@inflate
  01597	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
$LN318@inflate:

; 1224 :                 if (hold != (state->total & 0xffffffffUL)) {

  0159a	3b 51 20	 cmp	 edx, DWORD PTR [ecx+32]
  0159d	74 41		 je	 SHORT $LN328@inflate

; 1225 :                     strm->msg = (char *)"incorrect length check";

  0159f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015a2	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  015a9	c7 41 04 51 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16209 ; 00003f51H
  015b0	e9 d7 f5 ff ff	 jmp	 $LN8@inflate
$LN586@inflate:

; 844  :                 RESTORE();

  015b5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  015b8	8b 4d e0	 mov	 ecx, DWORD PTR _put$1$[ebp]
  015bb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx
  015be	8b 4d e8	 mov	 ecx, DWORD PTR _left$1$[ebp]
  015c1	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  015c4	8b 4d f8	 mov	 ecx, DWORD PTR _state$1$[ebp]
  015c7	89 38		 mov	 DWORD PTR [eax], edi
  015c9	89 58 04	 mov	 DWORD PTR [eax+4], ebx

; 845  :                 return Z_NEED_DICT;

  015cc	b8 02 00 00 00	 mov	 eax, 2
  015d1	5f		 pop	 edi
  015d2	89 71 40	 mov	 DWORD PTR [ecx+64], esi
  015d5	5e		 pop	 esi
  015d6	89 51 3c	 mov	 DWORD PTR [ecx+60], edx
  015d9	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  015da	8b e5		 mov	 esp, ebp
  015dc	5d		 pop	 ebp
  015dd	c2 08 00	 ret	 8
$LN328@inflate:

; 1226 :                     state->mode = BAD;
; 1227 :                     break;
; 1228 :                 }
; 1229 :                 INITBITS();

  015e0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _hold$1$[ebp], 0
  015e7	33 f6		 xor	 esi, esi
$LN327@inflate:

; 1230 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1231 :             }
; 1232 : #endif
; 1233 :             state->mode = DONE;

  015e9	c7 41 04 50 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16208 ; 00003f50H
$LN496@inflate:

; 1234 :         case DONE:
; 1235 :             ret = Z_STREAM_END;

  015f0	c7 45 d4 01 00
	00 00		 mov	 DWORD PTR _ret$1$[ebp], 1

; 1236 :             goto inf_leave;

  015f7	e9 c2 ef ff ff	 jmp	 $LN887@inflate
$LN497@inflate:

; 1237 :         case BAD:
; 1238 :             ret = Z_DATA_ERROR;

  015fc	c7 45 d4 fd ff
	ff ff		 mov	 DWORD PTR _ret$1$[ebp], -3 ; fffffffdH
  01603	e9 b6 ef ff ff	 jmp	 $LN887@inflate
$LN863@inflate:
  01608	8b 45 f4	 mov	 eax, DWORD PTR _have$1$[ebp]
  0160b	e9 b4 ef ff ff	 jmp	 $inf_leave$938
$LN503@inflate:

; 1260 :         }
; 1261 :     in -= strm->avail_in;

  01610	8b 45 c4	 mov	 eax, DWORD PTR _in$1$[ebp]
  01613	2b 47 04	 sub	 eax, DWORD PTR [edi+4]

; 1262 :     out -= strm->avail_out;

  01616	2b 77 10	 sub	 esi, DWORD PTR [edi+16]

; 1263 :     strm->total_in += in;

  01619	01 47 08	 add	 DWORD PTR [edi+8], eax

; 1264 :     strm->total_out += out;

  0161c	01 77 14	 add	 DWORD PTR [edi+20], esi

; 1265 :     state->total += out;

  0161f	01 73 20	 add	 DWORD PTR [ebx+32], esi

; 1266 :     if ((state->wrap & 4) && out)

  01622	f6 43 0c 04	 test	 BYTE PTR [ebx+12], 4
  01626	89 45 c4	 mov	 DWORD PTR _in$1$[ebp], eax
  01629	89 75 dc	 mov	 DWORD PTR _out$1$[ebp], esi
  0162c	74 26		 je	 SHORT $LN504@inflate
  0162e	85 f6		 test	 esi, esi
  01630	74 22		 je	 SHORT $LN504@inflate

; 1267 :         strm->adler = state->check =

  01632	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  01635	56		 push	 esi
  01636	2b c6		 sub	 eax, esi
  01638	83 7b 14 00	 cmp	 DWORD PTR [ebx+20], 0
  0163c	50		 push	 eax
  0163d	ff 73 1c	 push	 DWORD PTR [ebx+28]
  01640	74 07		 je	 SHORT $LN515@inflate
  01642	e8 00 00 00 00	 call	 _crc32@12
  01647	eb 05		 jmp	 SHORT $LN516@inflate
$LN515@inflate:
  01649	e8 00 00 00 00	 call	 _adler32@12
$LN516@inflate:
  0164e	89 43 1c	 mov	 DWORD PTR [ebx+28], eax
  01651	89 47 30	 mov	 DWORD PTR [edi+48], eax
$LN504@inflate:

; 1268 :             UPDATE(state->check, strm->next_out - out, out);
; 1269 :     strm->data_type = (int)state->bits + (state->last ? 64 : 0) +

  01654	8b 53 04	 mov	 edx, DWORD PTR [ebx+4]
  01657	81 fa 47 3f 00
	00		 cmp	 edx, 16199		; 00003f47H
  0165d	74 0c		 je	 SHORT $LN517@inflate
  0165f	81 fa 42 3f 00
	00		 cmp	 edx, 16194		; 00003f42H
  01665	74 04		 je	 SHORT $LN517@inflate
  01667	33 f6		 xor	 esi, esi
  01669	eb 05		 jmp	 SHORT $LN518@inflate
$LN517@inflate:
  0166b	be 00 01 00 00	 mov	 esi, 256		; 00000100H
$LN518@inflate:
  01670	8b 4b 08	 mov	 ecx, DWORD PTR [ebx+8]
  01673	f7 d9		 neg	 ecx
  01675	c7 45 08 80 00
	00 00		 mov	 DWORD PTR tv2674[ebp], 128 ; 00000080H
  0167c	1b c9		 sbb	 ecx, ecx
  0167e	33 c0		 xor	 eax, eax
  01680	83 e1 40	 and	 ecx, 64			; 00000040H
  01683	81 fa 3f 3f 00
	00		 cmp	 edx, 16191		; 00003f3fH
  01689	0f 44 45 08	 cmove	 eax, DWORD PTR tv2674[ebp]
  0168d	03 ce		 add	 ecx, esi
  0168f	03 c1		 add	 eax, ecx
  01691	03 43 40	 add	 eax, DWORD PTR [ebx+64]

; 1270 :                       (state->mode == TYPE ? 128 : 0) +
; 1271 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
; 1272 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01694	83 7d c4 00	 cmp	 DWORD PTR _in$1$[ebp], 0
  01698	89 47 2c	 mov	 DWORD PTR [edi+44], eax
  0169b	75 06		 jne	 SHORT $LN507@inflate
  0169d	83 7d dc 00	 cmp	 DWORD PTR _out$1$[ebp], 0
  016a1	74 06		 je	 SHORT $LN506@inflate
$LN507@inflate:
  016a3	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  016a7	75 16		 jne	 SHORT $LN895@inflate
$LN506@inflate:
  016a9	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016ac	b9 fb ff ff ff	 mov	 ecx, -5			; fffffffbH
  016b1	5f		 pop	 edi
  016b2	85 c0		 test	 eax, eax
  016b4	5e		 pop	 esi
  016b5	0f 44 c1	 cmove	 eax, ecx
  016b8	5b		 pop	 ebx

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  016b9	8b e5		 mov	 esp, ebp
  016bb	5d		 pop	 ebp
  016bc	c2 08 00	 ret	 8
$LN895@inflate:
  016bf	8b 45 d4	 mov	 eax, DWORD PTR _ret$1$[ebp]
  016c2	5f		 pop	 edi
  016c3	5e		 pop	 esi
  016c4	5b		 pop	 ebx
  016c5	8b e5		 mov	 esp, ebp
  016c7	5d		 pop	 ebp
  016c8	c2 08 00	 ret	 8
$LN333@inflate:

; 646  :         (strm->next_in == Z_NULL && strm->avail_in != 0))
; 647  :         return Z_STREAM_ERROR;

  016cb	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1273 :         ret = Z_BUF_ERROR;
; 1274 :     return ret;
; 1275 : }

  016d0	8b e5		 mov	 esp, ebp
  016d2	5d		 pop	 ebp
  016d3	c2 08 00	 ret	 8
  016d6	66 90		 npad	 2
$LN936@inflate:
  016d8	00 00 00 00	 DD	 $LN335@inflate
  016dc	00 00 00 00	 DD	 $LN32@inflate
  016e0	00 00 00 00	 DD	 $LN46@inflate
  016e4	00 00 00 00	 DD	 $LN60@inflate
  016e8	00 00 00 00	 DD	 $LN361@inflate
  016ec	00 00 00 00	 DD	 $LN368@inflate
  016f0	00 00 00 00	 DD	 $LN375@inflate
  016f4	00 00 00 00	 DD	 $LN384@inflate
  016f8	00 00 00 00	 DD	 $LN393@inflate
  016fc	00 00 00 00	 DD	 $LN105@inflate
  01700	00 00 00 00	 DD	 $LN400@inflate
  01704	00 00 00 00	 DD	 $LN402@inflate
  01708	00 00 00 00	 DD	 $LN403@inflate
  0170c	00 00 00 00	 DD	 $LN141@inflate
  01710	00 00 00 00	 DD	 $LN416@inflate
  01714	00 00 00 00	 DD	 $LN418@inflate
  01718	00 00 00 00	 DD	 $LN155@inflate
  0171c	00 00 00 00	 DD	 $LN532@inflate
  01720	00 00 00 00	 DD	 $LN535@inflate
  01724	00 00 00 00	 DD	 $LN448@inflate
  01728	00 00 00 00	 DD	 $LN450@inflate
  0172c	00 00 00 00	 DD	 $LN461@inflate
  01730	00 00 00 00	 DD	 $LN464@inflate
  01734	00 00 00 00	 DD	 $LN471@inflate
  01738	00 00 00 00	 DD	 $LN474@inflate
  0173c	00 00 00 00	 DD	 $LN485@inflate
  01740	00 00 00 00	 DD	 $LN487@inflate
  01744	00 00 00 00	 DD	 $LN492@inflate
  01748	00 00 00 00	 DD	 $LN496@inflate
  0174c	00 00 00 00	 DD	 $LN497@inflate
  01750	00 00 00 00	 DD	 $LN498@inflate
$LN937@inflate:
  01754	00 00 00 00	 DD	 $LN408@inflate
  01758	00 00 00 00	 DD	 $LN409@inflate
  0175c	00 00 00 00	 DD	 $LN411@inflate
  01760	00 00 00 00	 DD	 $LN412@inflate
_inflate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1279 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi

; 1280 :     struct inflate_state FAR *state;
; 1281 :     if (inflateStateCheck(strm))

  00004	8b 75 08	 mov	 esi, DWORD PTR _strm$[ebp]
  00007	8b ce		 mov	 ecx, esi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateEnd

; 1282 :         return Z_STREAM_ERROR;

  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5e		 pop	 esi

; 1289 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN2@inflateEnd:

; 1283 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 46 1c	 mov	 eax, DWORD PTR [esi+28]

; 1284 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0001f	8b 40 38	 mov	 eax, DWORD PTR [eax+56]
  00022	85 c0		 test	 eax, eax
  00024	74 0c		 je	 SHORT $LN3@inflateEnd
  00026	50		 push	 eax
  00027	ff 76 28	 push	 DWORD PTR [esi+40]
  0002a	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  0002d	ff d0		 call	 eax
  0002f	83 c4 08	 add	 esp, 8
$LN3@inflateEnd:

; 1285 :     ZFREE(strm, strm->state);

  00032	ff 76 1c	 push	 DWORD PTR [esi+28]
  00035	8b 46 24	 mov	 eax, DWORD PTR [esi+36]
  00038	ff 76 28	 push	 DWORD PTR [esi+40]
  0003b	ff d0		 call	 eax
  0003d	83 c4 08	 add	 esp, 8

; 1286 :     strm->state = Z_NULL;

  00040	c7 46 1c 00 00
	00 00		 mov	 DWORD PTR [esi+28], 0

; 1287 :     Tracev((stderr, "inflate: end\n"));
; 1288 :     return Z_OK;

  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi

; 1289 : }

  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateStateCheck
_TEXT	SEGMENT
_inflateStateCheck PROC					; COMDAT
; _strm$ = ecx

; 108  :     struct inflate_state FAR *state;
; 109  :     if (strm == Z_NULL ||
; 110  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0)

  00000	85 c9		 test	 ecx, ecx
  00002	74 2b		 je	 SHORT $LN3@inflateSta
  00004	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00008	74 25		 je	 SHORT $LN3@inflateSta
  0000a	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0000e	74 1f		 je	 SHORT $LN3@inflateSta

; 112  :     state = (struct inflate_state FAR *)strm->state;

  00010	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 113  :     if (state == Z_NULL || state->strm != strm ||
; 114  :         state->mode < HEAD || state->mode > SYNC)

  00013	85 c0		 test	 eax, eax
  00015	74 18		 je	 SHORT $LN3@inflateSta
  00017	39 08		 cmp	 DWORD PTR [eax], ecx
  00019	75 14		 jne	 SHORT $LN3@inflateSta
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	3d 34 3f 00 00	 cmp	 eax, 16180		; 00003f34H
  00023	7c 0a		 jl	 SHORT $LN3@inflateSta
  00025	3d 53 3f 00 00	 cmp	 eax, 16211		; 00003f53H
  0002a	7f 03		 jg	 SHORT $LN3@inflateSta

; 115  :         return 1;
; 116  :     return 0;

  0002c	33 c0		 xor	 eax, eax

; 117  : }

  0002e	c3		 ret	 0
$LN3@inflateSta:

; 111  :         return 1;

  0002f	b8 01 00 00 00	 mov	 eax, 1

; 117  : }

  00034	c3		 ret	 0
_inflateStateCheck ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateResetKeep@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateResetKeep@4 PROC				; COMDAT

; 121  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 122  :     struct inflate_state FAR *state;
; 123  : 
; 124  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00006	8b ca		 mov	 ecx, edx
  00008	e8 00 00 00 00	 call	 _inflateStateCheck
  0000d	85 c0		 test	 eax, eax
  0000f	74 09		 je	 SHORT $LN2@inflateRes
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 142  : }

  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
$LN2@inflateRes:

; 125  :     state = (struct inflate_state FAR *)strm->state;

  0001a	8b 4a 1c	 mov	 ecx, DWORD PTR [edx+28]

; 126  :     strm->total_in = strm->total_out = state->total = 0;

  0001d	c7 41 20 00 00
	00 00		 mov	 DWORD PTR [ecx+32], 0
  00024	c7 42 14 00 00
	00 00		 mov	 DWORD PTR [edx+20], 0
  0002b	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 127  :     strm->msg = Z_NULL;

  00032	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], 0

; 128  :     if (state->wrap)        /* to support ill-conceived Java test suite */

  00039	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  0003c	85 c0		 test	 eax, eax
  0003e	74 06		 je	 SHORT $LN3@inflateRes

; 129  :         strm->adler = state->wrap & 1;

  00040	83 e0 01	 and	 eax, 1
  00043	89 42 30	 mov	 DWORD PTR [edx+48], eax
$LN3@inflateRes:

; 130  :     state->mode = HEAD;
; 131  :     state->last = 0;
; 132  :     state->havedict = 0;
; 133  :     state->dmax = 32768U;
; 134  :     state->head = Z_NULL;
; 135  :     state->hold = 0;
; 136  :     state->bits = 0;
; 137  :     state->lencode = state->distcode = state->next = state->codes;

  00046	8d 81 34 05 00
	00		 lea	 eax, DWORD PTR [ecx+1332]
  0004c	c7 41 04 34 3f
	00 00		 mov	 DWORD PTR [ecx+4], 16180 ; 00003f34H
  00053	89 41 70	 mov	 DWORD PTR [ecx+112], eax
  00056	89 41 54	 mov	 DWORD PTR [ecx+84], eax
  00059	89 41 50	 mov	 DWORD PTR [ecx+80], eax

; 138  :     state->sane = 1;
; 139  :     state->back = -1;
; 140  :     Tracev((stderr, "inflate: reset\n"));
; 141  :     return Z_OK;

  0005c	33 c0		 xor	 eax, eax
  0005e	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00065	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0
  0006c	c7 41 18 00 80
	00 00		 mov	 DWORD PTR [ecx+24], 32768 ; 00008000H
  00073	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
  0007a	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0
  00081	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0
  00088	c7 81 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [ecx+7108], 1
  00092	c7 81 c8 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [ecx+7112], -1

; 142  : }

  0009c	5d		 pop	 ebp
  0009d	c2 04 00	 ret	 4
_inflateResetKeep@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateReset2@8
_TEXT	SEGMENT
_state$1$ = 8						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_inflateReset2@8 PROC					; COMDAT

; 160  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 161  :     int wrap;
; 162  :     struct inflate_state FAR *state;
; 163  : 
; 164  :     /* get the state */
; 165  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateRes
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 193  : }

  00018	5d		 pop	 ebp
  00019	c2 08 00	 ret	 8
$LN2@inflateRes:

; 166  :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 43 1c	 mov	 eax, DWORD PTR [ebx+28]
  0001f	56		 push	 esi

; 167  : 
; 168  :     /* extract wrap request from windowBits parameter */
; 169  :     if (windowBits < 0) {

  00020	8b 75 0c	 mov	 esi, DWORD PTR _windowBits$[ebp]
  00023	89 45 08	 mov	 DWORD PTR _state$1$[ebp], eax
  00026	57		 push	 edi
  00027	85 f6		 test	 esi, esi
  00029	79 06		 jns	 SHORT $LN3@inflateRes

; 170  :         wrap = 0;

  0002b	33 ff		 xor	 edi, edi

; 171  :         windowBits = -windowBits;

  0002d	f7 de		 neg	 esi

; 172  :     }

  0002f	eb 10		 jmp	 SHORT $LN5@inflateRes
$LN3@inflateRes:

; 173  :     else {
; 174  :         wrap = (windowBits >> 4) + 5;

  00031	8b fe		 mov	 edi, esi
  00033	c1 ff 04	 sar	 edi, 4
  00036	83 c7 05	 add	 edi, 5

; 175  : #ifdef GUNZIP
; 176  :         if (windowBits < 48)

  00039	83 fe 30	 cmp	 esi, 48			; 00000030H
  0003c	7d 03		 jge	 SHORT $LN5@inflateRes

; 177  :             windowBits &= 15;

  0003e	83 e6 0f	 and	 esi, 15			; 0000000fH
$LN5@inflateRes:

; 178  : #endif
; 179  :     }
; 180  : 
; 181  :     /* set number of window bits, free window if different */
; 182  :     if (windowBits && (windowBits < 8 || windowBits > 15))

  00041	85 f6		 test	 esi, esi
  00043	74 16		 je	 SHORT $LN6@inflateRes
  00045	83 fe 08	 cmp	 esi, 8
  00048	7c 05		 jl	 SHORT $LN7@inflateRes
  0004a	83 fe 0f	 cmp	 esi, 15			; 0000000fH
  0004d	7e 0c		 jle	 SHORT $LN6@inflateRes
$LN7@inflateRes:
  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi

; 183  :         return Z_STREAM_ERROR;

  00051	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00056	5b		 pop	 ebx

; 193  : }

  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
$LN6@inflateRes:

; 184  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  0005b	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0005e	85 c9		 test	 ecx, ecx
  00060	74 1b		 je	 SHORT $LN8@inflateRes
  00062	39 70 28	 cmp	 DWORD PTR [eax+40], esi
  00065	74 16		 je	 SHORT $LN8@inflateRes

; 185  :         ZFREE(strm, state->window);

  00067	8b 43 24	 mov	 eax, DWORD PTR [ebx+36]
  0006a	51		 push	 ecx
  0006b	ff 73 28	 push	 DWORD PTR [ebx+40]
  0006e	ff d0		 call	 eax

; 186  :         state->window = Z_NULL;

  00070	8b 45 08	 mov	 eax, DWORD PTR _state$1$[ebp]
  00073	83 c4 08	 add	 esp, 8
  00076	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0
$LN8@inflateRes:

; 187  :     }
; 188  : 
; 189  :     /* update state and reset the rest of it */
; 190  :     state->wrap = wrap;
; 191  :     state->wbits = (unsigned)windowBits;
; 192  :     return inflateReset(strm);

  0007d	53		 push	 ebx
  0007e	89 78 0c	 mov	 DWORD PTR [eax+12], edi
  00081	89 70 28	 mov	 DWORD PTR [eax+40], esi
  00084	e8 00 00 00 00	 call	 _inflateReset@4
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx

; 193  : }

  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
_inflateReset2@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 243  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 244  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	ff 75 10	 push	 DWORD PTR _stream_size$[ebp]
  00006	ff 75 0c	 push	 DWORD PTR _version$[ebp]
  00009	6a 0f		 push	 15			; 0000000fH
  0000b	ff 75 08	 push	 DWORD PTR _strm$[ebp]
  0000e	e8 00 00 00 00	 call	 _inflateInit2_@16

; 245  : }

  00013	5d		 pop	 ebp
  00014	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflatePrime@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_bits$ = 12						; size = 4
_value$ = 16						; size = 4
_inflatePrime@12 PROC					; COMDAT

; 251  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 252  :     struct inflate_state FAR *state;
; 253  : 
; 254  :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflatePri
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 266  : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflatePri:

; 255  :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]

; 256  :     if (bits < 0) {

  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _bits$[ebp]
  0001e	85 c9		 test	 ecx, ecx
  00020	79 14		 jns	 SHORT $LN3@inflatePri

; 257  :         state->hold = 0;

  00022	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 258  :         state->bits = 0;
; 259  :         return Z_OK;

  00029	33 c0		 xor	 eax, eax
  0002b	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 266  : }

  00032	5d		 pop	 ebp
  00033	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflatePri:
  00036	56		 push	 esi
  00037	57		 push	 edi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00038	83 f9 10	 cmp	 ecx, 16			; 00000010H
  0003b	7f 28		 jg	 SHORT $LN5@inflatePri
  0003d	8b 72 40	 mov	 esi, DWORD PTR [edx+64]
  00040	8d 3c 0e	 lea	 edi, DWORD PTR [esi+ecx]
  00043	83 ff 20	 cmp	 edi, 32			; 00000020H
  00046	77 1d		 ja	 SHORT $LN5@inflatePri

; 262  :     value &= (1L << bits) - 1;

  00048	b8 01 00 00 00	 mov	 eax, 1

; 263  :     state->hold += (unsigned)value << state->bits;
; 264  :     state->bits += (uInt)bits;

  0004d	89 7a 40	 mov	 DWORD PTR [edx+64], edi
  00050	d3 e0		 shl	 eax, cl
  00052	8b ce		 mov	 ecx, esi
  00054	48		 dec	 eax
  00055	23 45 10	 and	 eax, DWORD PTR _value$[ebp]
  00058	d3 e0		 shl	 eax, cl
  0005a	01 42 3c	 add	 DWORD PTR [edx+60], eax

; 265  :     return Z_OK;

  0005d	33 c0		 xor	 eax, eax
  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi

; 266  : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflatePri:
  00065	5f		 pop	 edi

; 260  :     }
; 261  :     if (bits > 16 || state->bits + (uInt)bits > 32) return Z_STREAM_ERROR;

  00066	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0006b	5e		 pop	 esi

; 266  : }

  0006c	5d		 pop	 ebp
  0006d	c2 0c 00	 ret	 12			; 0000000cH
_inflatePrime@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _fixedtables
_TEXT	SEGMENT
_fixedtables PROC					; COMDAT
; _state$ = ecx

; 281  : #ifdef BUILDFIXED
; 282  :     static int virgin = 1;
; 283  :     static code *lenfix, *distfix;
; 284  :     static code fixed[544];
; 285  : 
; 286  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 287  :     if (virgin) {
; 288  :         unsigned sym, bits;
; 289  :         static code *next;
; 290  : 
; 291  :         /* literal/length table */
; 292  :         sym = 0;
; 293  :         while (sym < 144) state->lens[sym++] = 8;
; 294  :         while (sym < 256) state->lens[sym++] = 9;
; 295  :         while (sym < 280) state->lens[sym++] = 7;
; 296  :         while (sym < 288) state->lens[sym++] = 8;
; 297  :         next = fixed;
; 298  :         lenfix = next;
; 299  :         bits = 9;
; 300  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 301  : 
; 302  :         /* distance table */
; 303  :         sym = 0;
; 304  :         while (sym < 32) state->lens[sym++] = 5;
; 305  :         distfix = next;
; 306  :         bits = 5;
; 307  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 308  : 
; 309  :         /* do this just once */
; 310  :         virgin = 0;
; 311  :     }
; 312  : #else /* !BUILDFIXED */
; 313  : #   include "inffixed.h"
; 314  : #endif /* BUILDFIXED */
; 315  :     state->lencode = lenfix;

  00000	c7 41 50 00 00
	00 00		 mov	 DWORD PTR [ecx+80], OFFSET ?lenfix@?1??fixedtables@@9@9

; 316  :     state->lenbits = 9;

  00007	c7 41 58 09 00
	00 00		 mov	 DWORD PTR [ecx+88], 9

; 317  :     state->distcode = distfix;

  0000e	c7 41 54 00 00
	00 00		 mov	 DWORD PTR [ecx+84], OFFSET ?distfix@?1??fixedtables@@9@9

; 318  :     state->distbits = 5;

  00015	c7 41 5c 05 00
	00 00		 mov	 DWORD PTR [ecx+92], 5

; 319  : }

  0001c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _updatewindow
_TEXT	SEGMENT
_end$1$ = -4						; size = 4
_copy$ = 8						; size = 4
_updatewindow PROC					; COMDAT
; _strm$ = ecx
; _end$ = edx

; 400  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	8b c2		 mov	 eax, edx
  00006	8b d1		 mov	 edx, ecx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	89 45 fc	 mov	 DWORD PTR _end$1$[ebp], eax

; 401  :     struct inflate_state FAR *state;
; 402  :     unsigned dist;
; 403  : 
; 404  :     state = (struct inflate_state FAR *)strm->state;
; 405  : 
; 406  :     /* if it hasn't been done already, allocate space for the window */
; 407  :     if (state->window == Z_NULL) {

  0000d	bf 01 00 00 00	 mov	 edi, 1
  00012	8b 72 1c	 mov	 esi, DWORD PTR [edx+28]
  00015	83 7e 38 00	 cmp	 DWORD PTR [esi+56], 0
  00019	75 26		 jne	 SHORT $LN3@updatewind

; 408  :         state->window = (unsigned char FAR *)

  0001b	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0001e	8b c7		 mov	 eax, edi
  00020	d3 e0		 shl	 eax, cl
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	ff 72 28	 push	 DWORD PTR [edx+40]
  00027	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002a	ff d0		 call	 eax
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 409  :                         ZALLOC(strm, 1U << state->wbits,
; 410  :                                sizeof(unsigned char));
; 411  :         if (state->window == Z_NULL) return 1;

  00032	85 c0		 test	 eax, eax
  00034	75 08		 jne	 SHORT $LN13@updatewind
  00036	8b c7		 mov	 eax, edi
  00038	5f		 pop	 edi
  00039	5e		 pop	 esi

; 444  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
$LN13@updatewind:
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
$LN3@updatewind:

; 412  :     }
; 413  : 
; 414  :     /* if window not in use yet, initialize */
; 415  :     if (state->wsize == 0) {

  00041	83 7e 2c 00	 cmp	 DWORD PTR [esi+44], 0
  00045	75 16		 jne	 SHORT $LN4@updatewind

; 416  :         state->wsize = 1U << state->wbits;

  00047	8b 4e 28	 mov	 ecx, DWORD PTR [esi+40]
  0004a	d3 e7		 shl	 edi, cl
  0004c	89 7e 2c	 mov	 DWORD PTR [esi+44], edi

; 417  :         state->wnext = 0;

  0004f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0

; 418  :         state->whave = 0;

  00056	c7 46 30 00 00
	00 00		 mov	 DWORD PTR [esi+48], 0
$LN4@updatewind:

; 419  :     }
; 420  : 
; 421  :     /* copy state->wsize or less output bytes into the circular window */
; 422  :     if (copy >= state->wsize) {

  0005d	8b 7e 2c	 mov	 edi, DWORD PTR [esi+44]
  00060	53		 push	 ebx
  00061	8b 5d 08	 mov	 ebx, DWORD PTR _copy$[ebp]
  00064	3b df		 cmp	 ebx, edi
  00066	72 25		 jb	 SHORT $LN5@updatewind

; 423  :         zmemcpy(state->window, end - state->wsize, state->wsize);

  00068	57		 push	 edi
  00069	2b c7		 sub	 eax, edi
  0006b	50		 push	 eax
  0006c	ff 76 38	 push	 DWORD PTR [esi+56]
  0006f	e8 00 00 00 00	 call	 _memcpy

; 424  :         state->wnext = 0;
; 425  :         state->whave = state->wsize;

  00074	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  00077	83 c4 0c	 add	 esp, 12			; 0000000cH

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  0007a	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
  00086	5b		 pop	 ebx
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi

; 444  : }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
$LN5@updatewind:

; 426  :     }
; 427  :     else {
; 428  :         dist = state->wsize - state->wnext;

  0008d	2b 7e 34	 sub	 edi, DWORD PTR [esi+52]

; 429  :         if (dist > copy) dist = copy;

  00090	3b fb		 cmp	 edi, ebx
  00092	0f 47 fb	 cmova	 edi, ebx

; 430  :         zmemcpy(state->window + state->wnext, end - copy, dist);

  00095	2b c3		 sub	 eax, ebx
  00097	57		 push	 edi
  00098	50		 push	 eax
  00099	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  0009c	03 46 34	 add	 eax, DWORD PTR [esi+52]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 _memcpy
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 431  :         copy -= dist;

  000a8	2b df		 sub	 ebx, edi

; 432  :         if (copy) {

  000aa	74 24		 je	 SHORT $LN8@updatewind

; 433  :             zmemcpy(state->window, end - copy, copy);

  000ac	8b 45 fc	 mov	 eax, DWORD PTR _end$1$[ebp]
  000af	53		 push	 ebx
  000b0	2b c3		 sub	 eax, ebx
  000b2	50		 push	 eax
  000b3	ff 76 38	 push	 DWORD PTR [esi+56]
  000b6	e8 00 00 00 00	 call	 _memcpy

; 434  :             state->wnext = copy;
; 435  :             state->whave = state->wsize;

  000bb	8b 46 2c	 mov	 eax, DWORD PTR [esi+44]
  000be	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c1	89 5e 34	 mov	 DWORD PTR [esi+52], ebx

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000c4	89 46 30	 mov	 DWORD PTR [esi+48], eax

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000c7	33 c0		 xor	 eax, eax
  000c9	5b		 pop	 ebx
  000ca	5f		 pop	 edi
  000cb	5e		 pop	 esi

; 444  : }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c3		 ret	 0
$LN8@updatewind:

; 436  :         }
; 437  :         else {
; 438  :             state->wnext += dist;

  000d0	01 7e 34	 add	 DWORD PTR [esi+52], edi

; 439  :             if (state->wnext == state->wsize) state->wnext = 0;

  000d3	8b 4e 2c	 mov	 ecx, DWORD PTR [esi+44]
  000d6	39 4e 34	 cmp	 DWORD PTR [esi+52], ecx
  000d9	75 07		 jne	 SHORT $LN10@updatewind
  000db	c7 46 34 00 00
	00 00		 mov	 DWORD PTR [esi+52], 0
$LN10@updatewind:

; 440  :             if (state->whave < state->wsize) state->whave += dist;

  000e2	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  000e5	3b c1		 cmp	 eax, ecx
  000e7	73 05		 jae	 SHORT $LN11@updatewind
  000e9	03 c7		 add	 eax, edi
  000eb	89 46 30	 mov	 DWORD PTR [esi+48], eax
$LN11@updatewind:

; 441  :         }
; 442  :     }
; 443  :     return 0;

  000ee	5b		 pop	 ebx
  000ef	5f		 pop	 edi
  000f0	33 c0		 xor	 eax, eax
  000f2	5e		 pop	 esi

; 444  : }

  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c3		 ret	 0
_updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateGetDictionary@12 PROC				; COMDAT

; 1295 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1296 :     struct inflate_state FAR *state;
; 1297 : 
; 1298 :     /* check state */
; 1299 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1312 : }

  00014	5d		 pop	 ebp
  00015	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateGet:
  00018	56		 push	 esi

; 1300 :     state = (struct inflate_state FAR *)strm->state;

  00019	8b 71 1c	 mov	 esi, DWORD PTR [ecx+28]

; 1301 : 
; 1302 :     /* copy dictionary */
; 1303 :     if (state->whave && dictionary != Z_NULL) {

  0001c	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0001f	85 c0		 test	 eax, eax
  00021	74 2f		 je	 SHORT $LN3@inflateGet
  00023	57		 push	 edi
  00024	8b 7d 0c	 mov	 edi, DWORD PTR _dictionary$[ebp]
  00027	85 ff		 test	 edi, edi
  00029	74 26		 je	 SHORT $LN6@inflateGet

; 1304 :         zmemcpy(dictionary, state->window + state->wnext,

  0002b	2b 46 34	 sub	 eax, DWORD PTR [esi+52]
  0002e	50		 push	 eax
  0002f	8b 46 38	 mov	 eax, DWORD PTR [esi+56]
  00032	03 46 34	 add	 eax, DWORD PTR [esi+52]
  00035	50		 push	 eax
  00036	57		 push	 edi
  00037	e8 00 00 00 00	 call	 _memcpy

; 1305 :                 state->whave - state->wnext);
; 1306 :         zmemcpy(dictionary + state->whave - state->wnext,

  0003c	8b 46 34	 mov	 eax, DWORD PTR [esi+52]
  0003f	2b f8		 sub	 edi, eax
  00041	03 7e 30	 add	 edi, DWORD PTR [esi+48]
  00044	50		 push	 eax
  00045	ff 76 38	 push	 DWORD PTR [esi+56]
  00048	57		 push	 edi
  00049	e8 00 00 00 00	 call	 _memcpy
  0004e	83 c4 18	 add	 esp, 24			; 00000018H
$LN6@inflateGet:
  00051	5f		 pop	 edi
$LN3@inflateGet:

; 1307 :                 state->window, state->wnext);
; 1308 :     }
; 1309 :     if (dictLength != Z_NULL)

  00052	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  00055	85 c9		 test	 ecx, ecx
  00057	74 05		 je	 SHORT $LN4@inflateGet

; 1310 :         *dictLength = state->whave;

  00059	8b 46 30	 mov	 eax, DWORD PTR [esi+48]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@inflateGet:

; 1311 :     return Z_OK;

  0005e	33 c0		 xor	 eax, eax
  00060	5e		 pop	 esi

; 1312 : }

  00061	5d		 pop	 ebp
  00062	c2 0c 00	 ret	 12			; 0000000cH
_inflateGetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1318 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1319 :     struct inflate_state FAR *state;
; 1320 :     unsigned long dictid;
; 1321 :     int ret;
; 1322 : 
; 1323 :     /* check state */
; 1324 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 7d 08	 mov	 edi, DWORD PTR _strm$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN2@inflateSet
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5f		 pop	 edi

; 1347 : }

  00018	5d		 pop	 ebp
  00019	c2 0c 00	 ret	 12			; 0000000cH
$LN2@inflateSet:
  0001c	56		 push	 esi

; 1325 :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 77 1c	 mov	 esi, DWORD PTR [edi+28]

; 1326 :     if (state->wrap != 0 && state->mode != DICT)

  00020	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  00024	74 14		 je	 SHORT $LN3@inflateSet
  00026	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  0002d	74 0b		 je	 SHORT $LN3@inflateSet

; 1327 :         return Z_STREAM_ERROR;

  0002f	5e		 pop	 esi
  00030	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00035	5f		 pop	 edi

; 1347 : }

  00036	5d		 pop	 ebp
  00037	c2 0c 00	 ret	 12			; 0000000cH
$LN3@inflateSet:

; 1328 : 
; 1329 :     /* check for correct dictionary identifier */
; 1330 :     if (state->mode == DICT) {

  0003a	81 7e 04 3e 3f
	00 00		 cmp	 DWORD PTR [esi+4], 16190 ; 00003f3eH
  00041	53		 push	 ebx
  00042	8b 5d 10	 mov	 ebx, DWORD PTR _dictLength$[ebp]
  00045	75 26		 jne	 SHORT $LN5@inflateSet

; 1331 :         dictid = adler32(0L, Z_NULL, 0);
; 1332 :         dictid = adler32(dictid, dictionary, dictLength);

  00047	53		 push	 ebx
  00048	ff 75 0c	 push	 DWORD PTR _dictionary$[ebp]
  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 _adler32@12
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 _adler32@12

; 1333 :         if (dictid != state->check)

  0005c	3b 46 1c	 cmp	 eax, DWORD PTR [esi+28]
  0005f	74 0c		 je	 SHORT $LN5@inflateSet

; 1334 :             return Z_DATA_ERROR;

  00061	5b		 pop	 ebx
  00062	5e		 pop	 esi
  00063	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00068	5f		 pop	 edi

; 1347 : }

  00069	5d		 pop	 ebp
  0006a	c2 0c 00	 ret	 12			; 0000000cH
$LN5@inflateSet:

; 1335 :     }
; 1336 : 
; 1337 :     /* copy dictionary to window using updatewindow(), which will amend the
; 1338 :        existing dictionary if appropriate */
; 1339 :     ret = updatewindow(strm, dictionary + dictLength, dictLength);

  0006d	8b 55 0c	 mov	 edx, DWORD PTR _dictionary$[ebp]
  00070	8b cf		 mov	 ecx, edi
  00072	53		 push	 ebx
  00073	8d 14 1a	 lea	 edx, DWORD PTR [edx+ebx]
  00076	e8 00 00 00 00	 call	 _updatewindow
  0007b	83 c4 04	 add	 esp, 4

; 1340 :     if (ret) {

  0007e	85 c0		 test	 eax, eax
  00080	74 13		 je	 SHORT $LN6@inflateSet

; 1341 :         state->mode = MEM;

  00082	5b		 pop	 ebx
  00083	c7 46 04 52 3f
	00 00		 mov	 DWORD PTR [esi+4], 16210 ; 00003f52H

; 1342 :         return Z_MEM_ERROR;

  0008a	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0008f	5e		 pop	 esi
  00090	5f		 pop	 edi

; 1347 : }

  00091	5d		 pop	 ebp
  00092	c2 0c 00	 ret	 12			; 0000000cH
$LN6@inflateSet:
  00095	5b		 pop	 ebx

; 1343 :     }
; 1344 :     state->havedict = 1;

  00096	c7 46 10 01 00
	00 00		 mov	 DWORD PTR [esi+16], 1

; 1345 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1346 :     return Z_OK;

  0009d	33 c0		 xor	 eax, eax
  0009f	5e		 pop	 esi
  000a0	5f		 pop	 edi

; 1347 : }

  000a1	5d		 pop	 ebp
  000a2	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateGetHeader@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_head$ = 12						; size = 4
_inflateGetHeader@8 PROC				; COMDAT

; 1352 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1353 :     struct inflate_state FAR *state;
; 1354 : 
; 1355 :     /* check state */
; 1356 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateGet
$LN5@inflateGet:
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1364 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateGet:

; 1357 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1358 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0001b	f6 41 0c 02	 test	 BYTE PTR [ecx+12], 2
  0001f	74 ee		 je	 SHORT $LN5@inflateGet

; 1359 : 
; 1360 :     /* save header structure */
; 1361 :     state->head = head;

  00021	8b 45 0c	 mov	 eax, DWORD PTR _head$[ebp]
  00024	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1362 :     head->done = 0;

  00027	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 1363 :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 1364 : }

  00030	5d		 pop	 ebp
  00031	c2 08 00	 ret	 8
_inflateGetHeader@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _syncsearch
_TEXT	SEGMENT
_buf$1$ = -8						; size = 4
_have$1$ = -4						; size = 4
_len$ = 8						; size = 4
_syncsearch PROC					; COMDAT
; _have$ = ecx
; _buf$ = edx

; 1381 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1382 :     unsigned got;
; 1383 :     unsigned next;
; 1384 : 
; 1385 :     got = *have;

  00006	8b 01		 mov	 eax, DWORD PTR [ecx]
  00008	56		 push	 esi
  00009	57		 push	 edi

; 1386 :     next = 0;
; 1387 :     while (next < len && got < 4) {

  0000a	8b 7d 08	 mov	 edi, DWORD PTR _len$[ebp]
  0000d	33 f6		 xor	 esi, esi
  0000f	89 55 f8	 mov	 DWORD PTR _buf$1$[ebp], edx
  00012	89 4d fc	 mov	 DWORD PTR _have$1$[ebp], ecx
  00015	85 ff		 test	 edi, edi
  00017	74 50		 je	 SHORT $LN13@syncsearch
  00019	53		 push	 ebx
  0001a	66 0f 1f 44 00
	00		 npad	 6
$LL2@syncsearch:
  00020	83 f8 04	 cmp	 eax, 4
  00023	73 36		 jae	 SHORT $LN14@syncsearch

; 1388 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00025	8a 1c 16	 mov	 bl, BYTE PTR [esi+edx]
  00028	83 f8 02	 cmp	 eax, 2
  0002b	0f b6 cb	 movzx	 ecx, bl
  0002e	1b d2		 sbb	 edx, edx
  00030	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00036	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003c	3b ca		 cmp	 ecx, edx
  0003e	75 03		 jne	 SHORT $LN4@syncsearch

; 1389 :             got++;

  00040	40		 inc	 eax
  00041	eb 10		 jmp	 SHORT $LN7@syncsearch
$LN4@syncsearch:

; 1390 :         else if (buf[next])
; 1391 :             got = 0;
; 1392 :         else
; 1393 :             got = 4 - got;

  00043	b9 04 00 00 00	 mov	 ecx, 4
  00048	33 d2		 xor	 edx, edx
  0004a	2b c8		 sub	 ecx, eax
  0004c	84 db		 test	 bl, bl
  0004e	8b c1		 mov	 eax, ecx
  00050	0f 45 c2	 cmovne	 eax, edx
$LN7@syncsearch:

; 1394 :         next++;

  00053	8b 55 f8	 mov	 edx, DWORD PTR _buf$1$[ebp]
  00056	46		 inc	 esi
  00057	3b f7		 cmp	 esi, edi
  00059	72 c5		 jb	 SHORT $LL2@syncsearch
$LN14@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _have$1$[ebp]
  0005e	5b		 pop	 ebx
  0005f	5f		 pop	 edi
  00060	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  00062	8b c6		 mov	 eax, esi
  00064	5e		 pop	 esi

; 1398 : }

  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
$LN13@syncsearch:

; 1395 :     }
; 1396 :     *have = got;

  00069	89 01		 mov	 DWORD PTR [ecx], eax

; 1397 :     return next;

  0006b	8b c6		 mov	 eax, esi
  0006d	5f		 pop	 edi
  0006e	5e		 pop	 esi

; 1398 : }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_in$1$ = 8						; size = 4
_buf$ = 8						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1402 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx

; 1403 :     unsigned len;               /* number of bytes to look at or looked at */
; 1404 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1405 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1406 :     struct inflate_state FAR *state;
; 1407 : 
; 1408 :     /* check parameters */
; 1409 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00004	8b 5d 08	 mov	 ebx, DWORD PTR _strm$[ebp]
  00007	8b cb		 mov	 ecx, ebx
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	74 0a		 je	 SHORT $LN4@inflateSyn
  00012	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00017	5b		 pop	 ebx

; 1441 : }

  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1410 :     state = (struct inflate_state FAR *)strm->state;
; 1411 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  0001c	83 7b 04 00	 cmp	 DWORD PTR [ebx+4], 0
  00020	57		 push	 edi
  00021	8b 7b 1c	 mov	 edi, DWORD PTR [ebx+28]
  00024	75 11		 jne	 SHORT $LN5@inflateSyn
  00026	83 7f 40 08	 cmp	 DWORD PTR [edi+64], 8
  0002a	73 0b		 jae	 SHORT $LN5@inflateSyn
  0002c	5f		 pop	 edi
  0002d	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  00032	5b		 pop	 ebx

; 1441 : }

  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
$LN5@inflateSyn:

; 1412 : 
; 1413 :     /* if first time, start search in bit buffer */
; 1414 :     if (state->mode != SYNC) {

  00037	81 7f 04 53 3f
	00 00		 cmp	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0003e	56		 push	 esi
  0003f	74 4f		 je	 SHORT $LN6@inflateSyn

; 1415 :         state->mode = SYNC;
; 1416 :         state->hold <<= state->bits & 7;

  00041	8b 57 40	 mov	 edx, DWORD PTR [edi+64]

; 1417 :         state->bits -= state->bits & 7;
; 1418 :         len = 0;

  00044	33 f6		 xor	 esi, esi
  00046	8b ca		 mov	 ecx, edx
  00048	c7 47 04 53 3f
	00 00		 mov	 DWORD PTR [edi+4], 16211 ; 00003f53H
  0004f	83 e1 07	 and	 ecx, 7
  00052	d3 67 3c	 shl	 DWORD PTR [edi+60], cl
  00055	2b d1		 sub	 edx, ecx
  00057	89 57 40	 mov	 DWORD PTR [edi+64], edx

; 1419 :         while (state->bits >= 8) {

  0005a	83 fa 08	 cmp	 edx, 8
  0005d	72 1c		 jb	 SHORT $LN3@inflateSyn
  0005f	8b 4f 3c	 mov	 ecx, DWORD PTR [edi+60]
$LL2@inflateSyn:

; 1420 :             buf[len++] = (unsigned char)(state->hold);

  00062	8a 47 3c	 mov	 al, BYTE PTR [edi+60]

; 1421 :             state->hold >>= 8;
; 1422 :             state->bits -= 8;

  00065	83 ea 08	 sub	 edx, 8
  00068	88 44 35 08	 mov	 BYTE PTR _buf$[ebp+esi], al
  0006c	46		 inc	 esi
  0006d	c1 e9 08	 shr	 ecx, 8
  00070	89 4f 3c	 mov	 DWORD PTR [edi+60], ecx
  00073	83 fa 08	 cmp	 edx, 8
  00076	73 ea		 jae	 SHORT $LL2@inflateSyn
  00078	89 57 40	 mov	 DWORD PTR [edi+64], edx
$LN3@inflateSyn:

; 1423 :         }
; 1424 :         state->have = 0;

  0007b	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]

; 1425 :         syncsearch(&(state->have), buf, len);

  0007e	8d 55 08	 lea	 edx, DWORD PTR _buf$[ebp]
  00081	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  00087	56		 push	 esi
  00088	e8 00 00 00 00	 call	 _syncsearch
  0008d	83 c4 04	 add	 esp, 4
$LN6@inflateSyn:

; 1426 :     }
; 1427 : 
; 1428 :     /* search available input */
; 1429 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00090	ff 73 04	 push	 DWORD PTR [ebx+4]
  00093	8b 13		 mov	 edx, DWORD PTR [ebx]
  00095	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  00098	e8 00 00 00 00	 call	 _syncsearch

; 1430 :     strm->avail_in -= len;

  0009d	29 43 04	 sub	 DWORD PTR [ebx+4], eax
  000a0	83 c4 04	 add	 esp, 4

; 1431 :     strm->next_in += len;

  000a3	01 03		 add	 DWORD PTR [ebx], eax

; 1432 :     strm->total_in += len;

  000a5	01 43 08	 add	 DWORD PTR [ebx+8], eax

; 1433 : 
; 1434 :     /* return no joy or set up to restart inflate() on a new block */
; 1435 :     if (state->have != 4) return Z_DATA_ERROR;

  000a8	83 7f 6c 04	 cmp	 DWORD PTR [edi+108], 4
  000ac	8b 43 08	 mov	 eax, DWORD PTR [ebx+8]
  000af	89 45 08	 mov	 DWORD PTR _in$1$[ebp], eax
  000b2	74 0c		 je	 SHORT $LN7@inflateSyn
  000b4	5e		 pop	 esi
  000b5	5f		 pop	 edi
  000b6	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  000bb	5b		 pop	 ebx

; 1441 : }

  000bc	5d		 pop	 ebp
  000bd	c2 04 00	 ret	 4
$LN7@inflateSyn:

; 1436 :     in = strm->total_in;  out = strm->total_out;

  000c0	8b 73 14	 mov	 esi, DWORD PTR [ebx+20]

; 1437 :     inflateReset(strm);

  000c3	53		 push	 ebx
  000c4	e8 00 00 00 00	 call	 _inflateReset@4

; 1438 :     strm->total_in = in;  strm->total_out = out;

  000c9	8b 45 08	 mov	 eax, DWORD PTR _in$1$[ebp]
  000cc	89 73 14	 mov	 DWORD PTR [ebx+20], esi
  000cf	89 43 08	 mov	 DWORD PTR [ebx+8], eax

; 1439 :     state->mode = TYPE;
; 1440 :     return Z_OK;

  000d2	33 c0		 xor	 eax, eax
  000d4	5e		 pop	 esi
  000d5	c7 47 04 3f 3f
	00 00		 mov	 DWORD PTR [edi+4], 16191 ; 00003f3fH
  000dc	5f		 pop	 edi
  000dd	5b		 pop	 ebx

; 1441 : }

  000de	5d		 pop	 ebp
  000df	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1453 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1454 :     struct inflate_state FAR *state;
; 1455 : 
; 1456 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateSyn
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1459 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateSyn:

; 1457 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1458 :     return state->mode == STORED && state->bits == 0;

  0001b	81 78 04 41 3f
	00 00		 cmp	 DWORD PTR [eax+4], 16193 ; 00003f41H
  00022	75 0f		 jne	 SHORT $LN4@inflateSyn
  00024	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  00028	75 09		 jne	 SHORT $LN4@inflateSyn
  0002a	b8 01 00 00 00	 mov	 eax, 1

; 1459 : }

  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
$LN4@inflateSyn:

; 1458 :     return state->mode == STORED && state->bits == 0;

  00033	33 c0		 xor	 eax, eax

; 1459 : }

  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_window$1$ = 12						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1464 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	57		 push	 edi

; 1465 :     struct inflate_state FAR *state;
; 1466 :     struct inflate_state FAR *copy;
; 1467 :     unsigned char FAR *window;
; 1468 :     unsigned wsize;
; 1469 : 
; 1470 :     /* check input */
; 1471 :     if (inflateStateCheck(source) || dest == Z_NULL)

  00004	8b 7d 0c	 mov	 edi, DWORD PTR _source$[ebp]
  00007	8b cf		 mov	 ecx, edi
  00009	e8 00 00 00 00	 call	 _inflateStateCheck
  0000e	85 c0		 test	 eax, eax
  00010	0f 85 2e 01 00
	00		 jne	 $LN3@inflateCop
  00016	39 45 08	 cmp	 DWORD PTR _dest$[ebp], eax
  00019	0f 84 25 01 00
	00		 je	 $LN3@inflateCop

; 1473 :     state = (struct inflate_state FAR *)source->state;
; 1474 : 
; 1475 :     /* allocate space */
; 1476 :     copy = (struct inflate_state FAR *)

  0001f	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  00022	53		 push	 ebx
  00023	8b 5f 1c	 mov	 ebx, DWORD PTR [edi+28]
  00026	56		 push	 esi
  00027	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0002c	6a 01		 push	 1
  0002e	ff 77 28	 push	 DWORD PTR [edi+40]
  00031	ff d0		 call	 eax
  00033	8b f0		 mov	 esi, eax
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1477 :            ZALLOC(source, 1, sizeof(struct inflate_state));
; 1478 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00038	85 f6		 test	 esi, esi
  0003a	74 38		 je	 SHORT $LN12@inflateCop

; 1479 :     window = Z_NULL;
; 1480 :     if (state->window != Z_NULL) {

  0003c	83 7b 38 00	 cmp	 DWORD PTR [ebx+56], 0
  00040	c7 45 0c 00 00
	00 00		 mov	 DWORD PTR _window$1$[ebp], 0
  00047	74 37		 je	 SHORT $LN6@inflateCop

; 1481 :         window = (unsigned char FAR *)

  00049	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	d3 e0		 shl	 eax, cl
  00053	6a 01		 push	 1
  00055	50		 push	 eax
  00056	ff 77 28	 push	 DWORD PTR [edi+40]
  00059	8b 47 20	 mov	 eax, DWORD PTR [edi+32]
  0005c	ff d0		 call	 eax
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00061	89 45 0c	 mov	 DWORD PTR _window$1$[ebp], eax

; 1482 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
; 1483 :         if (window == Z_NULL) {

  00064	85 c0		 test	 eax, eax
  00066	75 18		 jne	 SHORT $LN6@inflateCop

; 1484 :             ZFREE(source, copy);

  00068	8b 47 24	 mov	 eax, DWORD PTR [edi+36]
  0006b	56		 push	 esi
  0006c	ff 77 28	 push	 DWORD PTR [edi+40]
  0006f	ff d0		 call	 eax
  00071	83 c4 08	 add	 esp, 8
$LN12@inflateCop:

; 1485 :             return Z_MEM_ERROR;

  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0007b	5f		 pop	 edi

; 1506 : }

  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
$LN6@inflateCop:

; 1486 :         }
; 1487 :     }
; 1488 : 
; 1489 :     /* copy state */
; 1490 :     zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

  00080	0f 10 07	 movups	 xmm0, XMMWORD PTR [edi]
  00083	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 1491 :     zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));

  00086	68 d0 1b 00 00	 push	 7120			; 00001bd0H
  0008b	53		 push	 ebx
  0008c	56		 push	 esi
  0008d	0f 11 00	 movups	 XMMWORD PTR [eax], xmm0
  00090	0f 10 47 10	 movups	 xmm0, XMMWORD PTR [edi+16]
  00094	0f 11 40 10	 movups	 XMMWORD PTR [eax+16], xmm0
  00098	0f 10 47 20	 movups	 xmm0, XMMWORD PTR [edi+32]
  0009c	0f 11 40 20	 movups	 XMMWORD PTR [eax+32], xmm0
  000a0	f3 0f 7e 47 30	 movq	 xmm0, QWORD PTR [edi+48]
  000a5	66 0f d6 40 30	 movq	 QWORD PTR [eax+48], xmm0
  000aa	e8 00 00 00 00	 call	 _memcpy

; 1492 :     copy->strm = dest;

  000af	8b 7d 08	 mov	 edi, DWORD PTR _dest$[ebp]

; 1493 :     if (state->lencode >= state->codes &&

  000b2	8d 83 34 05 00
	00		 lea	 eax, DWORD PTR [ebx+1332]
  000b8	89 3e		 mov	 DWORD PTR [esi], edi
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  000bd	8b 4b 50	 mov	 ecx, DWORD PTR [ebx+80]
  000c0	3b c8		 cmp	 ecx, eax
  000c2	72 38		 jb	 SHORT $LN7@inflateCop
  000c4	8d 83 c0 1b 00
	00		 lea	 eax, DWORD PTR [ebx+7104]
  000ca	3b c8		 cmp	 ecx, eax
  000cc	77 2e		 ja	 SHORT $LN7@inflateCop

; 1494 :         state->lencode <= state->codes + ENOUGH - 1) {
; 1495 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  000ce	2b cb		 sub	 ecx, ebx
  000d0	8d 81 cc fa ff
	ff		 lea	 eax, DWORD PTR [ecx-1332]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000de	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000e1	89 46 50	 mov	 DWORD PTR [esi+80], eax

; 1496 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  000e4	8b 43 54	 mov	 eax, DWORD PTR [ebx+84]
  000e7	2b c3		 sub	 eax, ebx
  000e9	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  000ee	c1 f8 02	 sar	 eax, 2
  000f1	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  000f6	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  000f9	89 46 54	 mov	 DWORD PTR [esi+84], eax
$LN7@inflateCop:

; 1497 :     }
; 1498 :     copy->next = copy->codes + (state->next - state->codes);

  000fc	8b 43 70	 mov	 eax, DWORD PTR [ebx+112]
  000ff	2b c3		 sub	 eax, ebx
  00101	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00106	c1 f8 02	 sar	 eax, 2
  00109	05 4d 01 00 00	 add	 eax, 333		; 0000014dH
  0010e	8d 04 86	 lea	 eax, DWORD PTR [esi+eax*4]
  00111	89 46 70	 mov	 DWORD PTR [esi+112], eax

; 1499 :     if (window != Z_NULL) {

  00114	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00117	85 c0		 test	 eax, eax
  00119	74 1a		 je	 SHORT $LN8@inflateCop

; 1500 :         wsize = 1U << state->wbits;

  0011b	8b 4b 28	 mov	 ecx, DWORD PTR [ebx+40]
  0011e	ba 01 00 00 00	 mov	 edx, 1
  00123	d3 e2		 shl	 edx, cl

; 1501 :         zmemcpy(window, state->window, wsize);

  00125	52		 push	 edx
  00126	ff 73 38	 push	 DWORD PTR [ebx+56]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _memcpy
  0012f	8b 45 0c	 mov	 eax, DWORD PTR _window$1$[ebp]
  00132	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN8@inflateCop:

; 1502 :     }
; 1503 :     copy->window = window;

  00135	89 46 38	 mov	 DWORD PTR [esi+56], eax

; 1504 :     dest->state = (struct internal_state FAR *)copy;
; 1505 :     return Z_OK;

  00138	33 c0		 xor	 eax, eax
  0013a	89 77 1c	 mov	 DWORD PTR [edi+28], esi
  0013d	5e		 pop	 esi
  0013e	5b		 pop	 ebx
  0013f	5f		 pop	 edi

; 1506 : }

  00140	5d		 pop	 ebp
  00141	c2 08 00	 ret	 8
$LN3@inflateCop:

; 1472 :         return Z_STREAM_ERROR;

  00144	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00149	5f		 pop	 edi

; 1506 : }

  0014a	5d		 pop	 ebp
  0014b	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateUndermine@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_subvert$ = 12						; size = 4
_inflateUndermine@8 PROC				; COMDAT

; 1511 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1512 :     struct inflate_state FAR *state;
; 1513 : 
; 1514 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateUnd
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1523 : #endif
; 1524 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateUnd:

; 1515 :     state = (struct inflate_state FAR *)strm->state;
; 1516 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1517 :     state->sane = !subvert;
; 1518 :     return Z_OK;
; 1519 : #else
; 1520 :     (void)subvert;
; 1521 :     state->sane = 1;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001b	c7 80 c4 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [eax+7108], 1

; 1522 :     return Z_DATA_ERROR;

  00025	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH

; 1523 : #endif
; 1524 : }

  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
_inflateUndermine@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateValidate@8
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_check$ = 12						; size = 4
_inflateValidate@8 PROC					; COMDAT

; 1529 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1530 :     struct inflate_state FAR *state;
; 1531 : 
; 1532 :     if (inflateStateCheck(strm)) return Z_STREAM_ERROR;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateVal
  0000f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH

; 1539 : }

  00014	5d		 pop	 ebp
  00015	c2 08 00	 ret	 8
$LN2@inflateVal:

; 1533 :     state = (struct inflate_state FAR *)strm->state;
; 1534 :     if (check)

  00018	83 7d 0c 00	 cmp	 DWORD PTR _check$[ebp], 0
  0001c	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]
  0001f	74 0a		 je	 SHORT $LN3@inflateVal

; 1535 :         state->wrap |= 4;

  00021	83 48 0c 04	 or	 DWORD PTR [eax+12], 4

; 1538 :     return Z_OK;

  00025	33 c0		 xor	 eax, eax

; 1539 : }

  00027	5d		 pop	 ebp
  00028	c2 08 00	 ret	 8
$LN3@inflateVal:

; 1536 :     else
; 1537 :         state->wrap &= ~4;

  0002b	83 60 0c fb	 and	 DWORD PTR [eax+12], -5	; fffffffbH

; 1538 :     return Z_OK;

  0002f	33 c0		 xor	 eax, eax

; 1539 : }

  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
_inflateValidate@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateMark@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateMark@4 PROC					; COMDAT

; 1543 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1544 :     struct inflate_state FAR *state;
; 1545 : 
; 1546 :     if (inflateStateCheck(strm))

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 09		 je	 SHORT $LN2@inflateMar

; 1547 :         return -(1L << 16);

  0000f	b8 00 00 ff ff	 mov	 eax, -65536		; ffff0000H

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00014	5d		 pop	 ebp
  00015	c2 04 00	 ret	 4
$LN2@inflateMar:

; 1548 :     state = (struct inflate_state FAR *)strm->state;

  00018	8b 41 1c	 mov	 eax, DWORD PTR [ecx+28]

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	81 f9 43 3f 00
	00		 cmp	 ecx, 16195		; 00003f43H
  00024	75 12		 jne	 SHORT $LN6@inflateMar
  00026	8b 48 44	 mov	 ecx, DWORD PTR [eax+68]
  00029	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0002f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00032	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00034	5d		 pop	 ebp
  00035	c2 04 00	 ret	 4
$LN6@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00038	81 f9 4c 3f 00
	00		 cmp	 ecx, 16204		; 00003f4cH
  0003e	75 18		 jne	 SHORT $LN4@inflateMar
  00040	8b 88 cc 1b 00
	00		 mov	 ecx, DWORD PTR [eax+7116]
  00046	2b 48 44	 sub	 ecx, DWORD PTR [eax+68]
  00049	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0004f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00052	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
$LN4@inflateMar:

; 1549 :     return (long)(((unsigned long)((long)state->back)) << 16) +

  00058	8b 80 c8 1b 00
	00		 mov	 eax, DWORD PTR [eax+7112]
  0005e	33 c9		 xor	 ecx, ecx
  00060	c1 e0 10	 shl	 eax, 16			; 00000010H
  00063	03 c1		 add	 eax, ecx

; 1550 :         (state->mode == COPY ? state->length :
; 1551 :             (state->mode == MATCH ? state->was - state->length : 0));
; 1552 : }

  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
_inflateMark@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\users\lucas\documents\quazip\zlib1211\zlib-1.2.11\inflate.c
;	COMDAT _inflateCodesUsed@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateCodesUsed@4 PROC				; COMDAT

; 1556 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1557 :     struct inflate_state FAR *state;
; 1558 :     if (inflateStateCheck(strm)) return (unsigned long)-1;

  00003	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00006	e8 00 00 00 00	 call	 _inflateStateCheck
  0000b	85 c0		 test	 eax, eax
  0000d	74 07		 je	 SHORT $LN2@inflateCod
  0000f	83 c8 ff	 or	 eax, -1

; 1561 : }

  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
$LN2@inflateCod:

; 1559 :     state = (struct inflate_state FAR *)strm->state;

  00016	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]

; 1560 :     return (unsigned long)(state->next - state->codes);

  00019	8b 41 70	 mov	 eax, DWORD PTR [ecx+112]
  0001c	2b c1		 sub	 eax, ecx
  0001e	2d 34 05 00 00	 sub	 eax, 1332		; 00000534H
  00023	c1 f8 02	 sar	 eax, 2

; 1561 : }

  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
_inflateCodesUsed@4 ENDP
_TEXT	ENDS
END
